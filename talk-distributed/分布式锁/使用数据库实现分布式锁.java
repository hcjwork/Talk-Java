使用数据库做中间件可以实现跨JVM的分布式锁，但具体是根据什么机制来实现的，以及这种实现的机制的优缺点是什么，值得仔细探讨一下。
我们要实现的分布式锁通常都是具有互斥性的锁，即在某一时刻只允许持有锁的这一个线程操作，其他线程在锁释放之前一直等待。
那么数据库的什么机制可以实现这种互斥性，毫无意义要联系到数据库排他锁，而数据库锁有不同的粒度，有表锁、行锁、页锁、间隙锁等。
想到实际工程里存在不同的业务需要分布式锁，如果一个锁对应一张表，那实在太浪费空间和性能，而对应一页的也没必要，
完全可以是一行对应一个锁，比如以lock_key作为锁名称字段，订单业务的锁的lock_key为“order_key”，用户业务的锁的lock_key为“user_key”。

现在问题就来到了“有哪些方式可以用数据库的行锁来实现分布式锁的互斥性”。
行级排他锁一般有两种方式：一种就是在select行的时候主动添加锁，另一种就是利用update语句由数据库隐式添加锁。
比如在MySQL中，可以通过“select ... for update”在查询某一行的时候加排他锁，也可以通过“update...”隐式加锁。

下面以MySQL为例来探讨下行锁的排他性。
1）初始化分布式锁表
先创建一个分布式锁表，每行对应一个不同的分布式锁。
create table distributed_lock(
    id int not null auto_increment,
    lock_key varchar(32) not null,
    status char(1) default '0',
    thread_id varchar(64) default null,
    server_id varchar(16) default null,
    update_time timestamp default current_timestamp,
    primary key(id)
) auto_increment = 100001;
插入一行数据。
insert into distributed_lock(lock_key) values('order_key');

2）验证“select ... for update”和“update...”时行级锁的排他性
示例1：
begin;
select * from distributed_lock dl where dl.lock_key = 'order_key' for update;
commit;
-- 通过begin开启事务，执行select for update后，先不执行commit语句
-- 开启另一个窗口执行同样的“select for update”语句，此时会阻塞等待，等到第一个事务提交后，第二个语句立刻有了结果返回。

示例2：
begin;
update distributed_lock dl set status  = '1' where lock_key = 'order_key';
commit;
-- 通过begin开启事务，执行update语句后，先不执行commit语句
-- 开启另一个窗口执行同样的update语句，此时会阻塞等待，等到第一个事务提交后，第二个语句立刻有了结果返回。

这两种方式所加的锁确实具有排他性。

3）锁获取的顺序
update语句执行期间，其他线程可以执行select语句，但如果是执行select for update就会进入阻塞状态
update语句执行后但未提交，其他线程此时也对相同的行进行update操作也会进入阻塞状态。
但这里有个问题，假设有多个线程都执行到了同一个update语句，其中一个先进入数据库事务，相当于是先获得了锁，
在它未提交事务前，其他线程也进入了事务但被阻塞着无法执行update语句，而此时有两个或两个以上的线程都进入到了
准备执行update语句的状态，一旦持有锁的那个线程提交了事务，剩下的几个线程同时执行update语句，那谁是下一个获取到锁的？

获取锁的顺序与MySQL的版本实现有关。但无论是哪个版本，都离不开锁等待队列。
MySQL内部会被每个被锁定的行维护一个等待队列，当一个事务（或说线程）持有锁时，其他的在锁持续期间申请锁的事务（或说线程）会被放入这个等待队列。
其他事务或线程的锁等待信息可以通过“SELECT * FROM performance_schema.data_lock_waits;”语句进行查看：

在MySQL5.7及之前版本，基本上是以等待队列的FIFO顺序获取锁。
在MySQL8.0及之后版本，引入更复杂的调度算法，会综合考虑多个因素，比如事务等待时间（超时等待时间）、事务优先级、系统负载情况等，
申请锁的事务的等待时间会设置成有限时间，避免长时间饥饿；
事务的优先级也会被考虑，前提是设置了事务的优先级。
但在大多数情况下，锁获取的顺序表现类似于FIFO顺序，不过不会严格保证，尤其是在高并发场景下会有一些变化。

在验证“select for update”语句和update语句的排他性的时候，确实看到了阻塞等待锁的事务在等待一定时间后会报错，
提示“Lock wait timeout exceeded”。

4）代码怎么体现
有两种方式：① “select ... for update”语句 ② “update...”语句

事务提交方式：
首先要注意的点是，事务的提交方式需要设置为手动提交。我们需要再执行完成处理后再提交事务，需要控制提交的时机。
因为要进行手动提交，所以要使用原生JDBC进行操作，而非框架。

锁等待超时设置：
锁等待需要设置一个超时时间，可以避免线程长时间处于饥饿状态，也降低了锁等待的性能开销。
比如可以设置锁等待的最长时间为20s，在锁等待时间范围内，尝试获取锁，如果获取失败则休眠100ms后再继续尝试获取锁。

事务提交与连接关闭：
在执行完关键业务代码后，必须要记得提交事务，并释放锁，最后关闭连接。

锁获取和锁释放配套：
锁获取和锁释放方法要配套提供，避免没有及时释放锁而出现线程死锁。

5）关于事务和锁的思考
① 在持有锁的事务执行完成之前，其他申请同一个锁的事务会阻塞等待，为了避免等待锁的事务长时间饥饿，
需要为锁设置超时时间，或者为锁等待设置超时时间。
② 有些持续时间长的事务，可能在锁持续时间内无法完成，就需要一种看门狗机制为锁进行续期。
③ 为了减少阻塞时间，可以提供一种非阻塞申请锁的方式，如果没有获取预期结果时不进入阻塞队列。
④ 应尽量减少长事务，将长事务切割为短事务，非必要操作不放在事务内，在高并发场景下能降低锁等待的性能开销。

6）数据库锁的类型和作用范围
表锁（Table Lock）：锁住整张表，避免有其他变更操作干扰数据状态。通常在全盘扫描时应用，比如select*、索引增删改、视图创建等。
‌行锁（Record Lock）‌：锁住被UPDATE修改的具体行，防止其他事务修改该行‌。
‌间隙锁（Gap Lock）‌：锁住行记录之间的索引区间，防止其他事务插入新记录（仅在 REPEATABLE READ 隔离级别下使用）‌。
‌临键锁（Next-Key Lock）‌：在REPEATABLE READ隔离级别下，锁住索引记录及其间隙，防止幻读。
‌意向排他锁（IX Lock）‌：表示事务即将在某些行上加X锁，不会阻塞其他事务的行级锁，但会影响表级锁‌。


总结：
使用数据库实现分布式锁，本质是要依靠数据库自身提供的锁，还要结合事务的开启、提交与回滚等机制，锁的获取与释放效率并不高。
如果是在高并发场景下，数据库的压力会因为分布式锁的竞争而加剧，对业务数据的操作性能会有较大的影响，数据库的性能很快到达瓶颈，
因此不适合也不推荐使用数据库来实现分布式锁，除非确定并发强度低且对延迟有较大容忍性。