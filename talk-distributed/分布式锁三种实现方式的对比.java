分布式锁的三种经典实现方式是：数据库、Redis、Zookeeper。
得以实现分布式也就是跨JVM级别的锁，归根到底是因为是独立于JVM的中间组件。
以中间组件的角度从JVM抽离出来，实现JVM层面的线程访问互斥。

数据库实现分布式锁，是根据数据库本身锁提供的锁来实现，通常是一个业务对应一行锁记录，
可以利用update操作的隐式加锁来实现线程互斥，也可以在查询时附带for update关键词来显示加锁。
有加锁自然就有锁释放，而锁释放的时机需要控制在任务完成之后，所以需要使用原生JDBC进行事务开启、提交和回滚。
因为需要进行事务操作、还涉及到数据库锁，所以用数据库实现的分布式锁性能较低，如果遇到长事务对其他业务的处理影响较大，
一般很少牺牲数据库的性能来做分布式锁，除非是很低的并发，并且对锁的延迟有较大的容忍性。

Redis实现分布式锁，是根据Redis的nx相关指令来实现，nx是if not exists的简写，
意思是当键不存在的时候才去做某些事情，天然就具备一种互斥性。
有一个常用的是setnx命令，当键不存在的时候才去创建键并设值，但这个命令不支持设置键的过期时间，
如果想要用setnx命令来实现分布式锁，则需要结合expire命令一起给锁设置过期时间，给锁设置过期时间
是为了减少其他线程的等待，降低线程死锁的概率。
从Redis的2.6.12版本开始，引入了set nx ex/px命令，这是在原来的set ex/px命令上也添加了nx指令，
将nx和过期时间设置融合成了一个原子性指令，使用这条命令实现分布式锁要比setnx命令要简单，
锁删除则需要使用lua脚本将锁键的值进行查询确认的操作与锁键删除操作绑定为原子性操作，以免误删了别的线程设置的锁键。
为了增加不同线程对相同锁键所设值的区分度，通常结合uuid、业务id、随机串、实际戳来提高随机性。
数据库实现的分布式锁，其实是结合事务来控制的，只要事务不提交，任务可以一直执行，直到执行完后手动提交事务。
如果任务执行出现异常，事务作回滚，数据库对数据行加的锁会释放掉。
Redis其实没有这样的机制，如果不对锁键设置过期时间，就任务执行完成后手动删除锁键，但若是还未来得及就出现异常了，
将导致其他线程永远也无法对相同的锁键设置新的值，也就无法获取到分布式锁。为了避免这种情况，我们必须要对锁键设置
一个过期时间，这个过期时间设置多长可参考业务最大可能处理时间，当然也不一定要按最大可能处理时间来，因为不同的业务处理
所需的时间可能差异较大，其实设置个差不多的阈值就行，没执行完续期就好了。
有些业务处理的时间确实很长，我们可以在设计时切分为多个短任务，或是提取无需同步的处理放到同步范围外，也可以在获取锁的时候，
给等待和尝试设置一个超时时间，避免长时间等待长事浪费过多资源。
说到锁续期，就需要开启一个守护线程定期检查锁的剩余时间、检查持有锁的线程是否完成任务，遇到没有完成任务的就给锁键延续下时间。
而如何判定持有锁的线程是否完成任务，就需要定义一个用volatile修饰的全局锁状态，获取锁和释放锁成功时即时变更锁状态，
通过volatile保证全局锁状态的修改可见性，这样守护线程可以第一时间感知到锁状态并知晓持有锁的线程是否完成任务。

Zookeeper实现分布式锁，是根据Zookeeper提供的临时顺序节点来实现的。
临时性表示客户端断开连接时（主动断开或客户端崩溃）或会话结束时（每次会话都有个超时时间）Zookeeper会删除会话期间所创建的临时节点。
顺序性表示Zookeeper会给每个新建的节点名称拼上一个递增的序列号，通过这个序列号我们就可以找到最早创建的节点和线程新建节点的前一个节点。
只要客户端在会话期间没有停止发送心跳信息，服务端就不会认为客户端已断联，会话就能持续进行，如果会话快到期了，Zookeeper会自动续期。
这种会话机制天然地提供了Zookeeper做分布式锁的锁续期功能。另外会话失效时删除临时节点，也保证了锁的安全性，避免锁释放不及时而导致其他线程长久等待。
而节点名所拼接的序列号，让我们可以从小到大排序，序号更小的就是更早创建的，结合这个特性可以实现锁获取的公平性，让先申请锁的先获取到锁。
具体做法就是线程获取锁时都到同一目录下创建相同前缀的临时顺序节点，节点建好后，找到目录下序号最小节点与自己新建节点比对，
如果就是自己新建的那个节点，就表示直接获取到了锁；如果不是，则监听自己新建节点的前一个节点，监听其删除事件，只要被删除了，
说明锁被释放了，也就轮到自己持有锁了。
当然如果持有锁的线程提前执行完任务了，可以主动删除掉自己所建的临时节点，这样能较少其他线程的等待时间，进一步提高系统性能。

总结来说，这三种分布式锁的实现方式，数据库是很少用的，除非并发量低，不想引入Redis或Zookeeper。
Redis和Zookeeper用得更多，但两者各有长短处。
如果不是要求强一致性，用Redis更方便，因为Redis还经常用作缓存的；如果需要强一致性，则首选Zookeeper。
像金融行业比如银行，就可能优先选用Zookeeper而不是Redis。
