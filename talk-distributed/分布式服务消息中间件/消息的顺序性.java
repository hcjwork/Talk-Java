对于消息中间件来说，要讨论的问题很多，消息的顺序性绝对是一个重点。

首先从顺序性本身来说，在范围上有全局顺序性和局部顺序性之分，
为什么有全局和局部之分，因为消息中间件通常是采用集群模式进行部署，
能够提供消息组件功能的服务实例不止一个，消息的生产者和消息的消费者所属服务往往也是多实例部署，
这样的服务架构下，一条消息会被其中一个生产者生产、被其中一个消息中间件服务保存、被其中一个消费者消费，
那么多条消息之间在生产者生产、消息中间件保存、消费者消费这三个阶段中就都形成了顺序性。
消息中间件内部又通常分为主题、分区、队列、副本等子组件，一个中间件可能包含多个主题或多个分区或多个队列，
那么在这种子组件里的消息的顺序性称之为局部顺序性，而在所有组件层面都具有的顺序性称为全局顺序性。

另一角度是从逻辑性来看有物理顺序性和逻辑顺序性之分。
物理顺序性我们通常指的是数据在具体的存储设备中的相对位置，比如内存中、磁盘文件中依次存储。
逻辑顺序性指的是从业务的合理性上应该体现顺序性，比如订单创建要先于订单支付。

我们只关心逻辑上的顺序性要符合业务预期，至于物理顺序性的细节不太关注。
而全局顺序性和局部顺序性，如果要求严格顺序的业务，当然希望是满足全局顺序性，
全局顺序性满意满足或代价太大时，退而保持局部顺序性，通过固定指向比如一致性哈希算法，或者非并发性的模式来实现局部顺序性。

这次尝试从最简单的架构到更复杂的架构分层次讨论。
1、单生产者服务-单生产线程-单MQ服务-单消费者服务-单消费线程
这种架构里，生产者、消费者、MQ都只部署一个实例，生产线程和消费线程也只有单个。
无论是服务层面还是线程层面，都没有并发竞争，也就不存在消息乱序情况，因为每次只生产一个消息、保存一个消息、消费一个消息。
但这种架构极为原始，虽然安全但效率低下且可用性不足，现在微服务工程设计几乎不会采用。

2、单生产者服务-多生产线程-单MQ服务-单消费者服务-多消费线程
虽然是单个生产者服务，但如果一个用户同时发起多次相同的请求（通过不同客户端），调用生产者服务的同一个方法生产消息，
那么就会出现多个相同的消息被发送到MQ，所以MQ一般都提供了消息去重功能，比如幂等性通过<PID, Partition, SeqNumber>来保证。
当然这种重复消息天然是具有顺序性的，没有讨论的必要。
但如果是一条业务处理链路的不同节点的消息，比如订单创建、订单支付、订单完成三种消息，在业务处理链路上的顺序的合理排序
应该是先“订单创建”再“订单支付”最后是“订单完成”。
假设线程1生产“订单创建”消息，线程2生产“订单支付”消息，线程3生产“订单完成”消息。

同一个订单的3个节点消息会分散在3个并发线程操作里吗？
先明确一点，既然已经到节点消息生成这一步了，那么3个并发线程都已经在生产者服务执行这部分程序了。
所以不可能出现在一个生产者服务中的相同订单的不同节点消息，即便是这个用户是用不同客户端同时发起请求，
但也只能出现3个相同节点的消息，而不同节点的消息在逻辑上有时间差，所以天然分布在不同的时间点上。
因此这个问题的答案是，同一个订单的3个节点消息不可能会分散在3个并发线程操作里，同一个订单的3个节点消息只会分散在
3个非并发线程操作里。
不过如果是不同订单在3个不同节点的消息是可能会分散在3个并发线程操作里的，比如有三个订单，分别为“订单A、订单B、订单C”，
有三个并发线程分别为“线程1、线程2、线程3”，线程1操作的是订单A的“订单创建”消息，线程2操作的是订单B的“订单支付”消息，
线程3操作的是订单C的“订单完成”消息，这3个消息是可以在同一时刻产生的。
这3个消息分属于不同订单，我们允许它们并行，因为它们之间在业务上并没有顺序性需求。

结论是：单生产者服务架构下，在生产者这边，不用担心同一业务的消息在生产和发送时会出现乱序问题。不过业务节点重复发起的问题
是可能存在的，为了减少无效请求和数据库压力，可以考虑在进行业务处理时加锁和检查来保证幂等性。

同一订单的不同逻辑节点的消息在单生产者服务架构下天然具有时间顺序性，但有没有可能出现
“订单创建消息已经发送给了MQ服务，但MQ还没收到，订单支付消息就开始发送了”？
这个是有可能的，所以MQ服务要提供消息确认机制。
消息确认机制中，生产者发送消息给MQ，MQ成功接收并保存妥当后发一个确认信息给生产者，表示已经顺利接收到消息。

那如果生产者消息发出去了但还没被MQ服务接收到，就出现了网络数据丢失或MQ服务宕机，那这条消息就丢失了。
因此MQ服务端和MQ客户端都需要支持生产者消息发送重试，避免因为网络原因或MQ服务故障而导致生产者发送的消息丢失。

那如果生产者消息发送出去了，网络传输没问题，消息也确实到MQ服务了，但MQ刚好崩溃了，那这条消息也会丢失。
所以为了保证消息的可靠性，MQ服务通常要提供持久化存储的能力，这样在MQ服务恢复后能重新准备好待消费的消息。
当然也存在能容忍消息丢失的业务场景，所以MQ服务通常也支持内存存储，这样能提高消息交互的效率，但内存中的数据在重启后会被清除。

如果MQ服务正常接收到消息了，必然要按照某种规则依次保存消息，比如按照地址空间、文件行等，但这些硬件层面的顺序性对于
消息消费者来说太过底层，因此MQ服务通常要为每条消息在分区或队列层面添加唯一的递增序列号，这样方便消费者按顺序消费，
也更方面消息回溯。

从上面这段探讨中就发掘了消息中间件（MQ）要实现几个通用功能：
1）要支持消息发送重试机制。重试的具体实现，自然是要MQ来提供，但肯定不是MQ服务端来重新发送消息，而是通过消息生产者服务所
引入的MQ客户端服务来发起重试。因此MQ的客户端中要实现消息重新发送的功能，
2）要支持内存和持久化两种方式的存储机制。有些业务场景需要消息的高性能，有些业务场景需要消息的高可靠，
所以MQ要支持消息的内存存储和持久化存储（比如数据库、消息文件），甚至还需要支持两者的混合模式。
3）消息的存储要保持顺序性。内存的地址不一定是连续的，文件行也不同文件层面是不具备顺序性，
所以需要通过在分区或队列层面提供顺序性，为每个消息分配一个唯一且递增的序列号，比如offset消息位。
不仅可以方便消费者按顺序消费，也方便MQ自身精准查找定位。

3、单生产者服务-多生产线程-多MQ服务-单消费者服务-多消费线程
单MQ服务，该提供的功能都提供了，但就是可用性不足，如果这一个MQ服务宕机将导致整个消息中间件系统不可用，为了提高可用性，
通常采用多服务实例部署模式，采用多个提供相同功能的MQ服务来保障消息的高可用性。
那么MQ服务就要支持集群化部署，通常集群化部署有中心化和去中心化两种落地方式。
中心化就是指服务实例之间有主从之分，主节点负责写从节点负责读，主节点要将最新的数据同步给从节点。
去中心化就是服务实例之间没有主从之分，所有节点都负责读写，接收到写请求的节点，需要第一时间将写请求传递给其他剩余节点，
等到所有节点都处理好写请求后才认为请求完成。
实际工程实践中，这两种方式可能会结合使用，比如负责写请求的主节点也有多个，他们一起组成一个子集群来提供写服务。

而对于MQ客户端来说，多个MQ服务端，具体到底连哪一个需要有一种负载均衡算法，而所有MQ服务端的列表信息也需要拿到，
所以对于MQ系统来说，还需要提供MQ服务端注册和发现的功能，因为得知道哪些MQ服务是可以正常连接访问的，否则连接不了或
连到一个无法正常提供功能的MQ服务上，系统的可用性会大打折扣。
MQ系统要提供MQ服务端注册和发现的功能，MQ客户端要支持多种负载均衡策略，至少轮询、随机、一致性哈希这3种得支持。

关于消费线程，通常是由MQ客户端来创建，而不是消息消费者服务来创建。
消费者获取消息的方式又分为主动拉取和被动接收两种。
主动拉取就需要MQ服务端提供HTTP/RPC等接口机制，可以让消费者自行决定何时主动拉取。
被动接收就需要MQ服务端推送消息给消费者，通常是由MQ客户端与MQ服务端建立长连接，MQ服务端检测到消息有变更就推送给MQ客户端，
消费者自然就获取到了最新的消息。

但消费者并不需要所有的消息，只关心自己想要的那一类消息，因此MQ要提供消息类型的区分，这就是所谓的消息主题（Topic）。
同一类消息在业务上应该被分在同一个主题下，生产者生产消息发送时指定唯一主题名称，消费者拉取或接收推送的主题要与生产者发送消息
所指定的主题名称一致，否则无法正常获取到匹配的消息。
另外对于同一条消息，我们可能需要做多种处理，比如实时计算、统计分析、日志留存等，但如果这条消息被实时计算的消费线程消费了，
统计分析和日志留存就消费不到这条消息，因此考虑这种对同一套消息做不同业务处理的场景，MQ需要在消费者层面进行隔离区分，
这就是消费者组（Consumer Group），实时计算、统计分析、日志流程消费者都从同一个主题获取消息，各自的消息消费互不干扰。

当有多个消费者组订阅同一个主题的消息时，消费者组1提交消费位后，消费者组2再提交消费位，它们的消费节奏是不同频的，
因此为了保证消费者组都能独立消费全量消息，MQ服务中关于消息的消费记录需要在消费者组、主题层面都进行区分。

生产者生产的消息被MQ接收并存储，这些消息时在某个主题（Topic）下的，比如订单相关的消息在orders的主题下，
用户相关的消息在users的主题下。但在很多业务场景中，在业务大领域的层面的粒度还是太大了，例如订单领域包含有
很多个订单，有订单1、订单2、订单3，如果都是发布在orders主题下，所有订单全部一起存储，遇到只想要订单1消息的场景，
却获取到了订单2的消息，浪费了业务处理性能。
可以为每一个订单创建一个独立的主题，但这种策略会导致创建的主题数非常多，可能会压垮MQ服务，所以并非好的策略。
因此MQ服务通常还需要支持基于更小的粒度进行区分存储，比如分区或队列的概念。
主题下还有不同的分区或队列，这样能划分出更小的存储单元。分区之间或队列之间存储独立隔离。
生产者发送消息时，指定主题的同时，还应该可以指定主题下的分区或队列。
所以MQ客户端要实现分区或队列的负载均衡策略，至少实现轮询、随机、一致性哈希三种策略。
通过分区或队列，结合负载均衡，能并行处理同一主题下的不同业务。一致性哈希的负载均衡策略则可以让同一业务ID的相关消息
都分发到同一个分区或队列存储，从而在分区或队列层面实现消息的局部顺序性。

常见的消息中间件里，Kafka有分区，RocketMQ和RabbitMQ有队列。
Kafka的消息生产者在发送消息时可以直接指定分区；
RocketMQ的消息生产者在发送消息时无法直接指定分区，但可以通过自定义的队列选择器来制定队列的选择策略
（实现MessageQueueSelector接口，并在发送消息前指定队列选择器为自定义的选择器）；
RabbitMQ则是预先创建交换机和队列，队列创建时指定路由，交换机和队列通过路由键进行绑定， 
消息生产者发送消息时指定队列和路由键。







