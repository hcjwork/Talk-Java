消息经过生产者创建后，通过MQ客户端发送给MQ服务端，MQ服务端接收并保存消息，消费者通过MQ客户端向MQ服务端拉取消息后进行消费。
在这个流程中，有多次网络传输和数据中转，如果发生故障就会导致消息丢失。
实际工程部署设计里，MQ服务和生产者、消费者服务通常都是独立部署的，很少位于一台机器上，毕竟每台机器的资源有限。

生产者发送消息
生产者发送消息给MQ服务，如果消息还未到达MQ服务之前，就出现了网络故障，会导致消息在发送过程中丢失。
为了解决这种场景引起的消息丢失问题，MQ客户端支持消息发送的重试机制。重试指定次数依旧失败，则可以结合代码触发人工告警。

MQ服务接收消息
生产者发送的消息如果传输没有问题，但MQ服务接收后正准备保存消息时，MQ服务宕机了，这个新消息也会丢失掉。
为了解决这种场景引起的消息丢失问题，MQ服务端通常会支持消息的持久化保存，并通过MQ服务集群提高可用性。

MQ服务投递消息
消费者向MQ服务拉取最新消息，但消息在传输给消费者的过程中出现网络故障，会导致发给消费者的消息丢失。
为了解决这种场景引起的消息丢失问题，MQ服务会重新投递未消费的消息（在MQ客户端下次拉取时返回）。

消费者消费消息
当消费者通过批量方式向MQ服务拉取消息，如果其中有消息消费失败，但消费者提交了这批消息的整体偏移量，MQ服务会将
消费失败的消息标记为已消费，从而导致消息丢失。为了解决这种场景引起的消息丢失问题，实际消费时应当单条提交消息的偏移量，
只提交消费成功的消息的偏移量，这样MQ服务能在下次交互中重新投递消费失败的消息，可以避免消息丢失。
有些消息中间件支持消息消费失败次数记录，或是通过消费者提交的偏移量位置来判断消息是否重复消费，
但依赖MQ客户端反馈，或由消费者服务自行实现重试逻辑，比如消费失败的消息写入重试Topic。
例如：
RabbitMQ消息消费失败后，加入死信队列。
// 处理失败，拒绝消息并进入死信队列
channel.basicReject(message.getMessageProperties().getDeliveryTag(), false);
