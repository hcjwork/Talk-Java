在消息的生产、保存和消费的过程中，因为请求并发和重试机制的存在，对于消息的各种操作可能会出现重复执行，比如
消息的重复生产、消息的重复发送、消息的重复保存、消息的重复消费等。

解决消息的重复操作问题，就是消息幂等性的体现，即对某一条消息的各项操作只做一次有效执行。

消息生产的幂等性
生产者服务ID在MQ客户端和MQ服务端第一次连接时由MQ服务端进行分配，MQ客户端缓存在本地。
分区的编号则是MQ服务端在分区创建时从0开始编号。
消息的分区序列号由MQ客户端在本地维护，唯一且递增。
生产者服务ID也就是PID和消息的分区序列号，都是通过MQ客户端代码保存在内存中。
但如果生产者服务重启，PID就会重新分配，分区序列号也将从1开始，如果再发送相同的消息，MQ服务端就无法根据
“PID+分区号+分区序列号”的三元组信息来识别消息是否已经留存过。因为“PID+分区号+分区序列号”的三元组信息已经不同了。
所以“PID+分区号+分区序列号”的三元组信息只能在单会话内标识消息的唯一性，跨会话就起不到作用了。
如果想要在跨会话层面实现消息的唯一性，就需要启用事务，将PID和分区序列号在MQ服务端持久化存储，在生产者服务重启后，
恢复原来的PID和序列号。

消息发送的幂等性
消息生产后，发送给MQ服务的过程中，可能因为网络故障而导致消息丢失。为了解决消息丢失问题，MQ客户端提供消息发送重试功能。
那么在重试的过程本身就是对幂等性的破坏，但业务上对于消息发送本身的幂等性其实并没有要求。
而是对MQ服务队消息的留存的幂等性有要求，同样的消息理论上应该只在MQ服务中保存一次。

消息保存的幂等性
MQ服务不应限制消息发送的次数，但MQ服务要校验消息是否已经留存过，如果已经留存了，则不重复留存，直接返回消息接收确认信息。
MQ服务通常以“PID+分区号+分区序列号”三元组信息来判断消息是否已经留存。在不同MQ服务中，分区的概念也可能是队列。

消息消费的幂等性
消息理论上只应该被消费一次，对于消费失败的消息允许重新投递，只要消息的消费偏移量有且只被提交一次。
消费者与消息分区进行匹配，每个分区只分配给一个消息者消费。如果分区数小于消费者数，多余的消费者将处于空闲状态。
但如果消费者拉取到的消息中本身就存在重复消息，就会导致消息被重复消费。
消费者服务应该以MQ服务没有消息去重来进行消息消费幂等性的设计和处理，先查消费状态再决定是否处理消息。
比如业务状态表示已经处理过相同消息，便可认为新拉取的消息属于重复投递，忽略或直接直接消费偏移量即可。
非重复消息在正常处理后也要确保提交消费偏移量，避免MQ服务端重复投递。
对于消息是否重复，也可结合业务ID基于Redis进行记录和查验。或是结合本地消息记录表来实现消费幂等性。
