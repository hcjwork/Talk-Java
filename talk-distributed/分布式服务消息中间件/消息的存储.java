生产者创建消息后通过MQ客户端发送到MQ服务端，那么MQ服务免不了要保存消息，不然消费者没法消费到消息。
通常数据存储有内存和非内存两种方式，非内存就是指的磁盘文件方式。
基于内存存储消息，在MQ服务宕机或重启时会丢失所有消息，在可靠性方面不足，虽然内存中读写消息有很高的性能，
但很多业务对消息的可靠性要求较高，最多容忍极少部分的消息丢失，不能容忍大面积的消息丢失。
所以MQ服务对消息的存储除了内存外，必须还要支持非内存的方式，即持久化方式，就是要支持通过文件存储消息。

内存存储有高性能，文件存储有高可靠性，实际的MQ服务实现中可能是将两者结合起来，
写消息时，先写入文件，文件写入成功后，再写入内存；读消息时则优先从内存中取数据以提高效率。
但主流的消息中间件还是以持久化存储为主，一是为了防止消息丢失，二是因为内存优先而持久化方式能存储海量消息。
内存模式一般作为辅助用途比如用于高性能临时消息，或者用于特殊场景比如极低延迟但允许消息丢失。

对于主流的消息中间件，Kafka和RocketMQ都强制通过磁盘持久化方式来存储消息，它们对可靠性的设计有较大侧重，
而RabbitMQ除了持久化方式还是支持内存方式，其队列可以创建持久化的也可以创建非持久化，非持久化的就是内存队列。
内存队列在消息的读写方面有很高的性能，适用于要求低延迟但允许消息丢失的场景，比如实时监控数据。
所以内存队列是RabbitMQ相对于其他消息中间件的独特优势。