1、通用主题（Usually Topics）
学习如何构建这些系统时经常使用的工具类型包括：
1）远程过程调用（Remote Procedure Call，RPC）。 用以掩盖我们通过不可靠网络进行通信的事实。
2）线程（Thread）。这种编程技术能使我们利用多核计算机，提供了一种结构化并发操作的方式，旨在简化程序员对这些并发操作的视角。
3）并发控制（Concurrency Control）因为涉及到线程的并发操作，需要从实现层面出发，考虑并发控制，比如锁等机制。

2、可扩展性（Scalability）
所谓的可扩展性或可扩展加速，指的当使用一台计算机解决某个问题时，如果使用第二台计算机协作执行一同解决这个问题，
能够在一半的时间内解决问题，或者单位时间内在两台计算机上相较于之前一台计算机而言能解决两倍的问题。
大致来说，就是两倍的计算机或资源，能带来两倍的性能或吞吐量。
这是提高系统性能的其中一种方式，即通过购买布置更多台计算机或更多资源来提高系统性能，也就是所谓的横向扩展。
还有一种方式是，在程序的代码层面投入更多的成本去进行优化，这种就需要支付更多的费用让更多的程序员或程序员有更多的时间去重构或重组系统。
但实际落地中，程序即便应用了更高级的专业技术、更高效的算法，或者尝试其他不同的提效方案，很难对系统性能提升太多，
而通过购买布置更多计算机或资源对系统性能提升更为明显，所以可能更倾向于采买资源而不是提高人力或延长工期。

你开发的Web应用一开始只有一两个用户访问，用一台计算机足够了，但如果某天你的应用特别受欢迎，突然有了几百万的用户来注册，
此时 只用一台计算机是远远不够的，除非通过极其耗时的精细优化，否则无法支持数百万用户，但通常没有这样充足的时间也难以做到
这种程度的精细优化。
因此要加快处理速度，首先采取的措施是购买更多的Web服务器，并将用户分配到这些服务器上。比如现在共有两台计算机来提供服务了，
需要把一半的或一定比例的用户分配给第一台Web服务器，而另一半或剩下比例分配给第二台Web服务器。
考虑到不同用户对于某些数据要看到相同的效果，所以所有的Web服务器都要与后端数据库进行通信。
只要每个独立的Web服务器不给数据库带来过重的负担，就可以用更多的服务器来提高用户访问的并行处理速度。
但从整体链路来看，系统的性能瓶颈很快会出现在数据库上，因为上面这种扩展方式能提高的性能也是有限的，
一个是成本考量，不可能无休止地增加服务器；二是随着服务器数量庞大，用户分发的工作也会越来越复杂，每个服务器上分到的用户也会越来越多；
第三是数据库的压力并没有因Web服务器的扩展而减少，反而随着用户规模增大负载变得越来越大，数据库性能越来越低，整个系统因数据库开始出现性能瓶颈。
这相当于是通过部署大量的Web服务器将性能瓶颈转移到了数据库上。

那么如何解决数据库的性能瓶颈？
首先针对单一数据库本身，可以通过分表来降低单个表操作的数据量，但需要解决跨表分页问题。
或者是通过建立合理的索引，来提高查询速率。再或者是对SQL语句进行优化以提高数据库性能。
但这些措施性能提升也有限，尤其在数量级的提升，很难从500提升到10000，可能最多提升到个2000的样子。
所以想要更高的数据库性能，就需要进行一些设计，比如可以将原本存储在单一数据库中的排序数据进行重构，
使其分布于多个数据库之中，但这需要比较大的工作量。

3、容错性（Fault Tolerance）
当你部署了1000台计算机，每一台计算机按预期提供服务的持续时间是一年，这就意味着每天就有3台计算机发生故障或不能按预期提供服务。
因此在使用大型分布式系统解决大问题时，原本极为罕见的容错性和故障问题，会转变成持续性故障。
在这样有1000台计算机的系统中，总有一些计算机出现故障，或运行异常、运行缓慢，出现不合预期的操作。
而在这些计算机的物理机房内，用大量的网络电缆和交换机进行连接，因此可能会因为维护人员的踩踏或电缆脱落导致服务不可靠，
或者出现某个网络交换机的风扇损坏而导致交换机过热失效。
大规模的服务器将单体应用下极为罕见的问题转变为持续存在的问题，这意味着故障必须得到妥善处理，响应、故障屏蔽能力以及在无故障情况下
继续运行的能力，都必须融入系统的设计中。
这些持续性问题是每个分布式系统都需要面对的，但程序开发者也没有必要为所有可能发生的故障构建一个完整而复杂的应对方案，
其实只需要通用性的处理就差不多了。

4、可用性（Availability）
某些系统被设计成在特定类型的故障下依然能够持续运行，尽管发生了故，但仍能提供未受损的服务，即提供了与无故障情况下相同的服务。
这种状态的系统被称为是可用的。
而这种可用性的实现方式其中一种是副本机制，当其中一个副本服务器发生故障时，另一个服务器能够继续提供预期服务。

可用的系统通常表示在特定的故障集合下，能够继续如期提供服务。

5、可恢复性（Recover Ability）
当系统出现某些故障时可能会直接停止运行，但在修复问题后系统能够继续正常运行，好像从没有发生过任何故障一样。
在故障修复之前，我们不会采取任何行动。
在无需任何正确性损失的情况下，修复故障、重新启动、继续运行，也是很重要的能力要求。
为了保证无正确性损失，可恢复系统通常要执行如将最新状态保存到磁盘或其他可在电源恢复后取回的位置等操作。

一个具有实用性的系统，其规格说明会表示系统在发生一定数量的规模之前都是可用的。
但如果发生过多故障，这个可用的系统将会停止工作。
而在足够多的部件得到修复后，系统可以恢复运行。
因此，一个良好的可用系统在某种程度上也是可恢复的。

总结来说，可恢复就意味着先要做状态的持久化工作，等到恢复时把之前存储的状态显现出来。
在系统正常运行时定期或定量存储最新的数据状态。

解决容错和可恢复性问题的最重要的工具主要有两类：
1）非易失性存储
一旦发生服务崩溃、断电或其他异常情况时，可以利用硬盘、闪存、固态硬盘等非易失性存储介质，
来存储系统的检查点或状态日志。当问题解决后，我们能够从这些存储介质中读取最新的状态。
但非易失性存储介质的读写操作性能开销较高，所以在构建高容错系统时，应尽量避免过多地读写非易失性存储。
读写非易失性存储意味着移动磁盘臂并等待磁盘盘片旋转，这个过程非常耗时。
2）复制（副本机制）
由一台计算机升级为两台计算机，两台计算机都拥有系统状态完全相同的副本，当其中一个副本无法正常提供服务时，还有另一个副本继续提供服务。
副本管理的关键问题在于，两个副本可能因为某种意外出现不同步，无法继续作为彼此的副本存在。
副本机制不可避免地会出现副本间数据同步延迟的问题，如果要保证数据同步的强一致性，要么同时写入所有副本，要么等待副本全部同步完成才提供服务。
如果采用这种策略系统的可用性会大打折扣，所以要想保证系统有足够的可用性，只能实现数据同步的最终一致性。

6、一致性（Consistency）
在分布式系统中，由于复制、缓存或其他原因，数据可能存在多个版本，不同的用户对于同一数据访问得到的结果不相同，这就出现了数据不一致的问题。
数据一致性从强度来划分，分为强一致性和弱一致性。
对于强一致性的系统来说，需要保证任何用户在任何时间访问到的数据都是最新的。
而对于弱一致性的系统，允许用户在一定时间内访问到的是旧数据。
实际工程应用中人们对弱一致性有更大的兴趣，这是因为强一致性要求数据的每次访问都是最新的，这一要求的实现成本非常高，一般只有特定业务才会需要强一致性。
为了实现某种强一致性的概念，必须进行大量的通信。如果存在多个副本，无论是写操作还是读操作，都需要查阅或更新每一个副本，
以保证每次读写都覆盖到所有副本，避免用户访问到旧数据。
所以为减少通信，尤其是在副本距离较远（比如在不同城市的机房中），优先考虑构建弱一致性系统而不是强一致性系统。

在寻求使副本尽可能独立于故障以获得良好的容错能力的过程中，通常会将不同的副本分开部署在不同机房的不同服务器上，
以免因布置在相近相邻的机器上而一损俱损，从而进一步提升容错。 因此提供相同功能的不同副本，部署位置可能是在同一楼层的不同机房，
可能是在不同的城市，也可能是在不同的大洲、半球。
副本之间的物理距离越远，从一个副本同步最新数据到另一个副本中，通信开销比如耗时、网络带宽、流量等就会越大。