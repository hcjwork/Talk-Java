I/O是计算机程序中常见的编程交互场景，I是指输入Input，O是指输出Output。
输入和输出指的是数据的流向，读和写指的是数据的操作，输入输出与读写是同一过程的两种描述。
输入和输出是以程序为参照的，数据从程序外流转到程序内就是输入，数据从程序内流转到程序外就是输出。
程序内部的存储其实就是内存空间，因为程序是运行在内存中的。
所以从程序外的设备比如磁盘、网卡等将数据加载到程序内存中，就是数据输入程序的过程。
从程序的运行内存中将数据传递到程序外的设备比如磁盘、网卡等设备中，就是数据从程序往外输出的过程。

对数据的读或写操作需要有操作者来执行，这个操作者就是线程。而线程又分为用户线程和内核线程。
应用程序内的线程即为用户线程，操作系统内的线程即为内核线程。
所以对于I/O来说最关键的就是操作者和被操作者，操作者是线程，被操作者是数据。
数据的流转需要拷贝，数据的操作需要线程执行程序。
但无论数据是输入还是输出，最终都要涉及到物理设备，而物理设备通常只有内核才能直接访问，用户程序想访问必须由内核来做桥接。
有些特殊硬件支持绕过内核直接操作网卡，但安全性和通用性会大打折扣，这里我们只讨论通常情况。
所以在通常情况下，数据在不同设备间的流转一定有内核的参与，而用户线程则不一定。

而线程与I/O操作的协作模式决定了I/O任务的执行效率。

线程发起I/O操作后是否进入阻塞状态（即线程是否被挂起）决定了I/O操作是阻塞还是非阻塞的；
如果线程发起I/O操作后无法第一时间继续往下执行，表示I/O操作是阻塞的，否则是非阻塞的。

线程在发起I/O操作后是否等待I/O操作完成，决定了I/O操作是同步还是异步的；
如果线程在发起I/O操作后还要等待I/O操作结果，表示I/O操作是同步的，否则是异步的。

因此从阻塞非阻塞和同步非同步（即异步）的角度，I/O任务的模型可以分为：同步阻塞、同步非阻塞、异步非阻塞、异步阻塞。
但异步阻塞这种模型是不存在的，因为既然是异步的，说明发起I/O操作的线程会继续往下执行其他代码，而不会阻塞等待。
所以I/O的模型其实只包含“同步阻塞、同步非阻塞、异步非阻塞”三种，而异步又必然是非阻塞的。

同步阻塞I/O模型，也简称为阻塞I/O模型，因为异步必然不阻塞，所以提高阻塞就只有同步这种情形。
阻塞I/O，Blocking I/O（BIO），线程调用I/O操作后进入阻塞状态，当I/O操作完成后线程被唤醒。
在这种I/O模型下，每个连接都要占用一个线程，在高并发时消耗资源较大。

同步非阻塞I/O模型，也简称为非阻塞I/O模型。
非阻塞I/O，Non-blocking I/O（NIO），线程调用I/O操作后依然保持运行状态，但会不断轮询I/O操作结果，
等到I/O操作完成后结束轮询，继续执行下一步的任务。不阻塞线程，但轮询会消耗不少的CPU资源（CPU时间片）。

异步非阻塞I/O模型，简称为异步I/O模型。
异步I/O模型，Asynchronous I/O（AIO），线程调用I/O操作后继续往下执行，也不轮询I/O操作结果，I/O操作交由内核全权处理。
但需要指定I/O操作完成时的回调通知处理，包括正常和异常情形两种情况。

在同步I/O模型中，调用I/O操作的线程需要等待I/O操作的最终结果，并且要根据结果进行相应的处理；
而在异步I/O模型中，线程在调用I/O操作的同时只需指定回调处理，但不需要等待I/O操作的结果，
由内核负责数据的拷贝和传输，不用再经调用I/O操作的线程之手。

同步非阻塞I/O模型的关键是需要通过一种机制获取I/O操作的结果，再根据结果做相应处理，而获取I/O操作的机制，决定了
NIO的运行效率，原始做法是通过循环不断询问I/O操作结果，在大部分时间里并不会获取到结果，但线程却一直在执行，所以
浪费了很多CPU时间片。如果想减少CPU资源消耗，要想办法改善获取I/O操作的机制。
而一种获取I/O操作的机制就是通过事件驱动实现，发起I/O操作后监听I/O的操作状态的变更，当操作状态没有变更时线程进入阻塞状态，
操作状态变更时唤醒线程执行下一步处理。
虽然监听I/O操作状态时线程是阻塞的，但对于I/O操作本身线程是非阻塞的，因此这种就会事件监听和回调的机制，也是属于NIO的实现。
这类NIO实现有I/O多路复用和信号驱动I/O两种。



