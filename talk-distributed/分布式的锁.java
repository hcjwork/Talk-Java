1、什么是锁
锁其实就锁定的意思，锁定的可以是某个变量，也可以是某段程序代码。
背后转化出来就是对某个操作秉持独占性，其他争夺者想要操作就必须等待解锁状态。
锁的独占性由底层硬件指令提供，具体指令与处理器的实现有关，但通常会是某种互斥标志或是lock原子指令。

2、我们为什么需要锁
首先需要明确的一点是，如果是单线程环境下，我们不需要做锁定工作，因为访问数据、执行代码的都是同一个线程，
也就没有什么数据安全性的问题。
但是在现代处理器架构下，每个CPU都有多个核心，为了尽可能利用这些宝贵资源，应用程序通常都支持多线程并发运行，
这样能够大幅度提高系统的性能。
而在多线程环境下，很可能出现多个线程同时访问相同的数据或是执行相同的代码，看起来只是一行的代码被编译解析后，
常常被分解成多个子步骤逐一执行，这组子步骤在整体上并不具备原子性，为了不让线程加载到不合理的数据，以及为了保证
程序代码执行结果符合预期，我们就需要一种锁定措施，让一段代码在某一时刻只能被一个线程执行。

3、分布式锁前身的是什么
在分布式系统产生前，是一个个单体应用，那个时候也需要面对多线程并发执行的问题，但因为就一个JVM就搞定了，
所以只需要单机锁就能解决多线程并发问题。
单机锁也可以说是JVM层面的锁，作用范围也就到JVM的层次，java提供的这样的锁机制主要有三种：
一种是JVM内置锁synchronized，一种是API锁Lock，还有一种是CAS无锁编程。

4、为什么需要分布式锁
单机锁只能解决某一个JVM层面的线程并发问题，但如果是跨JVM的就束手无策了。
机器资源有限的时候，我们可能是一个机器上部署多个相同服务，只是启动的端口不同；
机器资源充足的时候，我们通常是在多台机器上部署多个相同服务，启动端口可以相同。
但不论是哪一种实施方式，一个JVM中的锁无法管制到另一个JVM的代码执行，因此就需要分布式锁来解决跨JVM的线程并发问题。

5、分布式锁怎么实现
如果不同的线程在不同的JVM中执行相同的代码，操作的是同一个数据，就需要一种在JVM层面之上的锁定策略，
即中间件策略。
比如用一个数据库表记录锁的状态和获取的锁线程ID、服务编号等信息，
比如使用Redis的setnx原子指令结合lua脚本进行跨JVM锁定，
再比如使用Zookeeper的临时节点实现跨JVM锁定。

6、分布式锁的核心问题
1）锁释放问题
锁必须要设置一个有限时间，时间到了自动释放，避免被无限制占用而导致其他线程迟迟等不到锁资源。
另外也要支持锁的主动释放，这样持有锁的线程执行完后第一时间释放锁资源，减少其他线程的等待时间。
如果锁不释放，就可能造成死锁。
2）锁删除问题
在一些分布式锁实现中，可能是使用某个标识作为锁，为了提高业务逻辑的独立性，避免删除掉不合预期的锁，
需要给锁绑定其他的唯一标志，以增强不同业务间锁的区分度，其次要检验无误后再删除。
3）锁续期问题
在锁持续的过程中，可能存在持续锁的线程还没有执行完任务，锁就已经过期的情形，为了避免这种情况发生，
需要为锁开启一个守护线程，在锁过期前的一小段时间里（比如过期前10s）检查线程是否完成了任务，如果没有完成，
则为锁续上一段时间。例如Redisson中使用了watchdog守护线程，监察锁快过期时线程的任务是否完成，如果没有完成则默认续期30s。
当然锁的持续时间、锁过期前多久时间检查、锁续期多久，都应该可以进行配置和调整的，以增强锁管理的灵活性。
4）集群问题
为了提高分布式锁的可用性，我们可能会搭建集群来提供分布式锁功能，比如搭建Redis集群提供分布式锁功能，
但集群有一些无法避免的问题比如节点宕机、主从切换、新增锁的节点同步等。
比如原来在维护在主节点的最新锁状态还没有来得及完全同步到从节点，主节点突然宕机了，从节点升级为了主节点，
此时在新的主节点上出现了一些锁不可用或不存在的问题。
为了解决这种问题，我们可以在变更锁状态的时候，要求每个节点都更新落实了才算完成。
但这样效率会比较低，其实只要超过半数的节点完成更新了就可以算操作成功了，因为不可能同时存在两组超半数的节点完成，
例如3个节点组成的集群，在某一时刻只可能有一组超过半数2的节点完成了锁更新操作。
这就是红锁算法，只要集群中超过半数的节点完成锁状态的变更，就认为变更操作已经成功了。通过红锁算法，能够提高不少性能。
