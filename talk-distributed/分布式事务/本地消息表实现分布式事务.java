本地消息表，从这个定义就可以看出肯定跟本地事务相关的，又跟消息队列有关。
其实就是通过消息队列来进行分布式事务的参与者之间的通信，
但并不是在本地事务提交时就通过MQ发送消息，而是在数据库中建立消息表，
把对消息表的写入与业务数据的操作放在一个本地事务中进行提交，
消息表的记录包含消息主题、消息内容、消息发送状态、重试次数等信息，
然后由定时任务定期扫描消息表去发送消息给下游的参与者，当然下游的参与者需要监听约定好的消息主题。

消息表中记录当前参与者的补偿接口回调url，业务数据变更和消息记录放在同一本地事务中执行提交，
对应的方法使用@Transactional注解自动提交或回滚次对应的本地事务。
定时任务扫描消息表，还没有发送的消息通过MQ发布出去，下游服务监听约定好的主题。

提供消息发送失败的重试机制，设置重试次数阈值，比如最多重试三次，重试次数用完后如果还是发送消息失败，
考虑发送告警邮件或短信，在消息表的可视化界面上展示对应的消息信息并提供重试按钮，采用人工方式兜底，
或者是将发送失败的消息加入死信队列，但其实没有什么必要，实际采用人工兜底的方式更多。

下游服务如果监听到对应的主题消息，先检查对应的订单是否已经有了下游服务的处理记录，如果有了就不重复处理，
如果没有处理过，就正常处理。这是下游服务正向操作的幂等性保证。
如果下游服务正向操作失败，调用补偿处理，根据唯一的业务ID查找关联的未完成的消息，逐个处理，调对应的补偿回调方法，
然后标记消息为已取消。

每个参与者，业务数据变更和分布式事务消息记录在同一个事务中提交，每个服务都有自己的分布式事务消息记录表。
每个服务都要有定时任务去扫描自己的消息记录表，发送消息给下游服务，失败后重试一定次数，如果还失败就告警让人工处理。
每个服务都有页面可以查看消息记录的发送情况，以及重试按钮等可供人工操作。
每个服务提交消息记录时，需要包含全局业务ID、全局事务ID、消息内容、消息主题、消息状态、消息重试次数、补偿回调接口url等关键信息。
下游服务的正向操作如果失败，就要调用补偿处理方法，补偿处理方法中查找关联业务ID的每一个未发送的消息，
逐个调用对应的补偿回调方法执行补偿操作。
所以除了最下游的服务，每个上游服务都需要准备好补偿方法，或者所有的服务都应该准备好补偿方法以供回调。

假设一个分布式事务的业务处理链路从上到下依次为：订单服务、支付服务、库存服务。
订单服务的正向操作：查询业务ID，订单是否已存在。不存在则创建并保存订单，然后创建并保存事务消息。
订单服务的反向操作：修改订单状态为“已取消”。
订单服务的定时任务：扫描订单服务的本地消息表，查找没有发送的或发送次数没有到达上限的，通过MQ发送消息。

支付服务的正向操作：查询业务ID对应支付记录是否已存在，如果已存在，直接结束。如果不存在则进行支付交易处理和消息记录。
支付服务的反向操作：回退支付交易，将支付状态修改为“已取消”，并调用专门的补偿处理器，查找相关联的所有未完成的消息，调对应的补偿接口。
支付服务的定时任务：扫描支付服务的本地消息表，查找没有发送的或发送次数没有到达上限的，通过MQ发送消息。

库存服务的正向操作：查询业务ID对应支付记录是否已存在，如果已存在，直接结束。如果不存在则进行支付交易处理和消息记录。
                库存服务是最下游的，可以直接不记录事务消息。
库存服务的反向操作：因为扣减库存失败，又是最下游的，所以不需要操作库存数据了，直接是事务回滚。
                只需要调用专门的补偿处理器，查找相关联的所有未完成的消息，调对应的补偿接口。
库存服务的定时任务：不需要。
