Saga模式通过多个本地事务配合补偿机制来实现分布式事务。
只要是补偿型的分布式事务，就无法实现强一致性，只能实现最终一致性。

多个本地事务，说明是一个参与方一个事务。
补偿机制，需要搞清楚怎么个补偿法，谁来执行这个补偿操作。

补偿操作，即反向操作，也称作为冲正操作。就是跟正向操作反着来。
无论是正向操作还是补偿操作，理论上都应该要具备幂等性的，不允许多次重复执行，如果检测到已执行过了，直接结束处理即可。

补偿操作肯定是要在正向操作出现异常的时候执行，如果正向操作顺利执行自然就不需要什么补偿操作。
那么补偿操作的执行依据是什么？至少要清楚正向操作做了些什么，才能知道怎么反着来做补偿操作。

通常有两种实现方式：一是由协调者协调执行各个服务的正向和补偿操作，二是各个服务通过事件或消息进行通信来确定下一步的操作。
由协调者统一协调执行正向和补偿操作的方式，称为协同式Saga；
通过服务间通信来执行正向和补偿操作的方式，称为编排式Saga。
不管是协同式Saga还是编排式Saga，其实都是通过中间组件来协调整个分布式事务的正向和反向操作。

如果采用协同式Saga，则需要一个协调器来统一协调管理各个本地事务的正反向操作。
如果采用编排式Saga，利用事件驱动来进行服务通信，可以使用Spring的Event实现；
如果采用编排式Saga，利用消息传递来进行服务通信，可以使用MQ如Kafka、RabbitMQ等。

协同式Saga
核心组件：Saga执行器、Saga步骤、Saga协调器、Saga已执行步骤
SagaStep类中要体现正向操作和补偿操作，Saga协调器负责组装相关服务的SagaStep信息，
Saga执行器负责执行各个服务的正向和补偿操作，如果每个服务的正向操作都执行成功就无需执行补偿操作，
每执行一个SagaStep，就将已执行的SagaStep存入集合，一旦出现某个SagaStep执行失败，就开始执行补偿操作。
可以定义一个ExecutedStep包装一下SagaStep，再提供一个执行是否成功的标识。
补偿操作的执行过程就是把收集到的ExecutedStep逆序遍历，然后逐个执行对应的补偿方法。
每个服务都要提供一个正向操作方法和一个补偿操作方法。

编排式Saga-事件通信
各参与者的正向和补偿操作事件定义；
下游参与者监听上游的事件并进行处理；
最上游参与者收集所有参与者的操作状态，统一发起确认或取消事件。

编排式Saga-消息通信
各参与者定义正向和补偿两种操作；
下游参与者同样要监听上游的消息传递，监听到变动再进行处理；
最上游参与者要提供Saga协调器，监听其他服务的消息，根据不同服务的不同事件（哪一级的参与者，正向操作还是反向操作），
发布新的事件触发更下游的服务进行处理，
比如分布式事务涉及订单、库存、支付三个服务，理论上先创建订单然后扣减库存最后进行支付。
在这条业务处理链路中，订单服务是最上游的参与者，需要创建订单并发布订单创建消息（消息可以是事件），
下游的库存服务监听订单服务发布的消息：
如果是订单创建消息，就执行库存扣减任务；如果是订单取消消息，就只想库存回退任务。
例如：
// 订单服务的订单创建消息和订单取消消息都发布到order-saga-events主题
@KafkaListener(topics = "order-saga-events")
public void listenOrderEvents(ConsumerRecord<String, Object> record) {
    AbstractEvent event = (AbstractEvent) record.value();
    if (event instanceof OrderCreatedEvent) {
        // 是订单创建消息，就执行库存扣减任务
        processOrderCreated((OrderCreatedEvent) event);
    } else if (event instanceof OrderCancelledEvent) {
        // 是订单取消消息，就执行库存回退任务
        processOrderCancelled((OrderCancelledEvent) event);
    }
}
最下游的支付服务所做工作类似与库存服务。
此外最上游的订单服务，还要提供Saga协调器监听库存服务和支付服务的事件，然后发起更下游的处理事件，
但在发布前需要检查Saga状态避免重复处理。

编排式Saga比协同式Saga复杂得多，就拿事件通信方式来说，每个本地事务的参与者都需要准备正向和反向操作的监听事件，
下游的参与者要监听上游的两个事件，但这种单向传递性的监听会有问题，比如订单服务、库存服务、支付服务，
库存服务监听到订单服务的订单创建事件后，准备扣减库存但出现异常，此时取消扣减库存事件被下游的支付服务监听到，
支付服务取消支付，但订单却是实实在在创建了的并没有取消。要解决这个问题，监听要具有循环性，订单服务要监听支付服务，
那么问题又来了，这样循环监听很大可能会导致无限循环。

为了解决这种循环依赖，可以采用状态机+版本号的方式，
所谓的状态机就是状态标识，由分布式事务的最先发起者也就是最上游的参与者统一协调，
下游的参与者执行各自负责的处理后，先不确认，而是发布一种准备中状态的事件，
由最上游的确认无误后再统一发布确认事件。
而为了保持幂等性，避免重复执行，使用版本号进行区分，如果是旧的版本号就不再重复执行而是直接结束处理。

无论是事件实现的编排式Saga，还是消息实现的编排式Saga，比协同式Saga都复杂得多，要考虑和解决的边界问题也更多，
实际工程里还是优先选用成熟的框架来实现Saga模式的分布式事务，比如
基于事件的编排式Saga模式可选用：Axon Framework；
基于消息的编排式Saga模式可选用：Apache Camel Saga。
如果需要较强的一致性，可以结合TCC模式。








