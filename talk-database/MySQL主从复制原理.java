MySQL主从复制需要主节点和从节点的紧密配合，主节点负责写入数据变更，并将数据变更记录在binlog日志文件中，
从节点不负责外部写入数据变更，而是通过I/O线程从主库拉取binlog日志并写入自己的`relay log`日志中，`relay log`日志称为
中继日志，也就是中转用的，然后通过SQL线程读取`relay log`重放其中的SQL语句，也就是逐一执行`relay log`的SQL语句。

MySQL从库主动向主库请求binlog，能解耦主库压力，从库也能自由控制拉取节奏，从库宕机后恢复，只需要从断点继续拉取，主库无感知。
主库发送binlog给从库时一般采用增量发送方式，只有在第一次同步或主从数据差异过大时才会采用全量发送方式。
binlog的刷盘模式支持异步刷盘和同步刷盘，由`sync_binlog`参数控制，异步刷盘模式效率会更高但可能会丢失少量数据，
同步刷盘模式更安全但性能较低，`sync_binlog`参数如果设置为大于1的数N则会采用折中方案，即每N次事务提交后刷盘，
性能和安全性介于异步刷盘和同步刷盘之间，具有更好的平衡性。

中间件或者说涉及到数据同步的，一般都是数据副本向数据主本主动拉取，这样能控制数据同步节奏，也能减轻主本各项压力。
比如日志留存系统生成文件存储在sftp服务器上，下游系统定时或定量向日志留存系统文件服务器拉取日志文件解析处理。
比如Kafka消费者通过Kafka客户端定时向Kakfa服务端拉取最新的未消费的消息。

主从复制流程
1、主库接收到外部数据变更请求，记录数据变更到binlog日志文件中。
2、从库定时通过I/O线程向主库请求binlog。
3、主库通过BinlogDump线程发送binlog给从库。
4、从库接收到主库的binlog后暂存在自己的relaylog日志文件中。
5、从库通过SQL线程读取自己的relaylog日志文件，重放其中的SQL，最终保持数据与主库一致。

从这个过程可以看到，主从复制必然会带来数据的时延性，主从数据库作为一个整体系统对外提供读写服务，用户可能读取到旧的数据，
这是牺牲了一定数据一致性换来了高可用性。
从库需要主动向主库拉取binlog日志，再暂存到自己的`relay log`日志中，最后再解析执行`relay log`中的SQL语句。
那么写入主库的SQL的复杂度就影响着主从数据同步工作的耗时，写入主库的SQL越复杂，同步到从库的所耗时间就越长。
而且从库为了保证SQL重放顺序，避免并行复制冲突，与主库保持同样的事务隔离级别，会跟主库一样在执行SQL时加锁，
比如执行DML语句时会加行锁、执行DDL语句时会加表锁，但锁的竞争远低于主库，因为只需SQL线程内部协调。
虽然锁的开销低于主库，但加锁本身就意味着耗时增加，因此应当尽量减少从库的加锁时间。

主从复制时延优化
1、减少大事务
尽量避免使用复杂的SQL，尽可能拆分为小的简单的SQL。事务的持续时间越长，从库复制时所带来的锁性能消耗就越大。
2、启用并行复制
MySQL5.7+支持基于组提交的并行复制（slave_parallel_workers > 1），锁机制协调多线程回放。
根据CPU核心数调整并发复制工作线程数。
例如：
STOP SLAVE;
SET GLOBAL slave_parallel_workers = 4;  -- 根据CPU核心数调整
START SLAVE;
3、避免从库长时间查询
从库的只读查询可能持有快照，这会阻塞从库的SQL线程清理`undo log`。

Binlog、Redo Log、Undo Log
1、binlog
数据库服务层面的逻辑日志，记录SQL、行变更信息等，用于主从复制、数据恢复等场景，可长期保留，保留时间可配置。
2、redo log
存储引擎InnoDB的物理日志，记录数据页变更，用于崩溃恢复场景，可保证持久性，大小固定，会随着时间推移循环覆盖。
3、undo log
存储引擎InnoDB的逻辑日志，记录的是数据旧值，用于事务回滚、MVCC等场景，在事务提交后逐步清理。
