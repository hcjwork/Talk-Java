二级索引：
索引树的非叶子节点值存储索引字段值，叶子节点只存储索引字段值和对应主键值。整个索引树的所有节点都不存储具体数据行，
需要先通过索引字段值找到对应的主键值，再通过主键值在主键索引中定位到具体的数据行。因此被称为二级索引。

回表：
当使用二级索引（如普通索引、唯一索引）查询时，若所需字段未完全包含在索引中，需根据索引找到的主键值，
再回到主键索引（聚簇索引）中查找完整数据行的过程。又称为索引回表或SQL回表。

是否回表的关键就在于，能否只通过一次索引查找就能得到对应的数据行。如果能就不需要回表，比如主键索引；如不能，则需要回表。
只有聚簇索引比如主键索引才会存储具体数据行，因此只有聚簇索引才算是一级索引，其余的非聚簇索引都是二级索引。
比如唯一索引、普通索引、联合索引都算二级索引，主键索引算一级索引。

因此对于二级索引，就有了索引覆盖或覆盖索引的概念，所谓索引覆盖就是指要查询的字段被索引包含的字段范围所完全覆盖。
此时因为能直接在索引树中完全找到要返回的数据，就不需要再去主键索引查找，即不需要进行回表操作，能提高查询效率。

索引覆盖时可以避免全表扫描，还能避免主键索引扫描，只需要扫描本身的索引就能获取到完整数据。
例如表tab基于a和b两个字段建立了联合索引idx_a_b，有如下三种查询：
① select a,b from tab; 
② select * from where a = 1;
③ select * from where c = 1;
对于查询语句①，只查a和b两个字段，这两个字段的值在联合索引idx_a_b中能找到，因此只需要扫描联合索引idx_a_b即可，性能最高。
对于查询语句②，查表的所有字段，但因为where中用到了索引字段a，且符合联合索引的最左前缀原则，因此联合索引idx_a_b生效，
但因为所查字段不止a和b，因此需要先在联合索引idx_a_b根据a=1定位到对应的主键值，在用主键值去扫描主键索引获取数据行。
因此要经历联合索引idx_a_b和主键索引两次扫描过程，性能较低。
对于查询语句③，查表的所有字段，c字段又并非索引字段，因此要查找c=1条件下的数据行，必须进行全表扫描，比较每一行c字段的值是否等于1。
性能最差。

由此可见索引覆盖所带来的性能提升，工程实践中应该尽量避免查询不必要的字段，比如select *，
如果确实要查询表的所有字段（这种需求场景也不少的），尽可能应用索引，比如给where子句筛选字段建立索引，
给join字段、外键关联字段建立索引。而且要避免索引失效，比如给针对筛选字段使用函数、隐式转换、前置模糊匹配等，
会导致数据库引擎放弃使用索引而转为全表扫描。
因为一旦需要进行这种转换或函数调用，原本的索引树中并没有记录转换后或函数调用的结果，即便是扫描了索引也不会得到想要的结果，
而且数据库根本不知道扫描哪个索引树，如果一定要使用索引，就必须要扫描所有索引，此时全表扫描反而成了更直观更方便的处理方式。


