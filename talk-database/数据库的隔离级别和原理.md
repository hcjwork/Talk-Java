数据库的操作概述起来其实就是读和写两种类型，读就是从数据库系统中获取到已有的数据，写就是将数据新的变更写入到数据库中。
在单个事务（单个数据库连接、单个数据库线程）中，读还是写都是这个事务所自行把控的，读到什么、写到什么都有一定的预期。
而在并发事务场景中，虽然每个事务之间的操作是互不干扰的，但如果这些事务操作的是同一张表甚至是同一行数据，事务A的读写就会
收到事务B读写的影响或者影响到事务B的读写，从而产生各种问题，当然问题的严重程度是有差别的。

1、脏读
事务操作中的数据状态变化只有当前事务可以感知到，如果当前事务没有提交，其他事务理论上看不到此事务对数据的修改。
如果事务B读取到了事务A已修改但尚未提交的数据，这就是脏读问题。

2、不可重复读
事务中第一次对数据集的读取结果是1，经过一段时间后第二次读取同一数据得到的结果是2，当前事务本身没有对数据进行修改，但读取到
的数据却发生了变化，一定是有其他事务对此数据做了变更操作。这就是不可重复读的问题，事务前后两次数据读取所得结果不一致。

3、幻读
事务中根据同一条件进行多次数据读取，在此期间有其他事务新增或删除了符合条件的数据，导致多次读取的结果集不同。这就是幻读问题。

这三种问题的粒度从小到大为：脏读、不可重复读、幻读，数据库对这些问题不同解决方案称为数据库的隔离级别。
脏读、不可重复读、幻读都未解决的隔离级别称为：读未提交（Read Uncommitted）。
解决了脏读但没有解决不可重复读和幻读的隔离级别称为：读已提交（Read Committed）。
解决了脏读和不可重复读但没有解决幻读的隔离级别称为：可重复读（Repeatable Read）。
解决了脏读、不可重复读和幻读的隔离级别称为：串行化（Serializable）。

读已提交的隔离级别禁止其他事务读取当前事务尚未提交的数据；
可重复读的隔离级别禁止其他事务读取当前事务尚未提交的数据，同时也禁止当前事务读取其他事务尚未提交的数据；
串行化的隔离级别在事务对数据做变更时禁止其他所有事务的读或写操作。

主流数据库都有自己的默认隔离级别，MySQL的默认隔离级别是可重复读，Oracle、PostgreSQL、SQL Server等的默认隔离级别是
读已提交，SOLite的默认隔离级别是串行化。
隔离级别越高事务的隔离性越强，数据操作的安全性也就越高，但数据库的并发性能就会越低，
因此实际应用中对隔离级别的启用要平衡安全性和性能，通常来说保持数据库的默认隔离级别就行。
如果有更高的隔离性需求，根据业务特殊性酌情提高级别，也可以在业务代码中实现。
当然对于一些安全性要求很高而并发量较低的业务，比如金融业务，可以直接采用可重复读或串行化的隔离级别。

读未提交的隔离级别性能最高但数据的安全性、一致性最差，一般极少使用。

四种隔离级别的实现对比
读未提交：无锁、无版本控制。
读已提交：采用多版本并发控制（Multi Version Concurrency Control，MVCC），每个事务看到的数据是快照（Snapshot）版本。
事务修改数据时加行级锁，阻止其他事务同时修改。
可重复读：事务开始时创建数据快照，事务持续期间全程读取该快照版本，即采用MVCC+快照隔离保证事务读取同一数据的一致性。通过
间隙锁（Gap Lock）阻止其他事务在查询范围内插入新数据或删除数据，以避免幻读。
串行化：采用严格锁机制，读时加共享锁，写时加排他锁，事务串行执行。通常通过悲观锁或乐观锁+冲突检测实现，性能代价高。









