一、索引数据结构的变迁过程
现代数据库通常都使用B+树作为索引数据结构，B+树是多路平衡树，是基于B树优化的。
但B+树经历了多次尝试和变革才找到的高效索引结构，由早期的简单线性结构逐渐变迁而来。

1、文件结构
在关系型数据库出现的早期，还没有完善的索引结构，只是基于磁盘的文件进行数据扫描和查找。
文件行因为写入有时间先后天然具备一定的顺序性，但这种顺序性是完全线性的，而且无法从中间行或末尾行开始查找，
只能从第一行开始查找，平均时间复杂度为O(n)。

2、有序的数组结构
文件行虽然在文件中天然具有顺序性，但每次查找数据时只能从第一行开始，基本就是全表扫描，无法有更高的效率。
如果能够将这种顺序性用数组结构体现，则既可以从开端的数据查起，也能从末尾的的数据查起。
但如果仅仅是这样，平均时间复杂度同样为O(n)，因为也要进行线性扫描。不过对于有序的数组来说，还有种更高效的做法，
即二分查找。因为顺序性，通过二分查找法可以将数据查找效率降低到O(logN)，但插入和删除的平均时间复杂度依然是O(n)。
相对于原始的文件结构，有序数组的数据查找效率提高了不少，灵活性也得到了增强。

3、哈希表结构（Hash Table）
哈希表是键值对存储结构，一个key对应一个value。哈希表本身也是基于数组结构实现的，但数组本身不具有固定key的功能。
哈希表通过对key进行哈希值计算，再用哈希值根据数组长度取模，这样相同哈希值对应的key-value键值对就会路由到数组中相同的
位置存储。计算哈希值并基于哈希值对于数组长度取模，能定位到数组下标，通过数组下标可以定向访问，时间复杂度为O(1)。
这就是为什么有序数组不使用二分查找法的时间复杂度是O(n)，而哈希表基于数组实现，查询的时间复杂度能降低到O(1)。
但从中可以看到，可能会存在不同key计算出来的数组下标是相同，此时造成了存储位置冲突，这就是所谓的哈希冲突。
为了解决哈希冲突，通常使用链表将存储位置冲突的键值对串联起来存储在数组的同一位置。在链表长度较短时，查询的时间复杂度
依然还能算O(1)，但如果链表长度较大，因为链表本身要遍历查找，时间复杂度就会来到O(n)，因此哈希表结构在大数据量中
时间复杂度退化明显。并且哈希表结构只适合等值查询，无法支持范围查询，如果是范围查询，哈希表结构的查询时间复杂度将退化为O(n)。

4、二叉搜索树（BST）
为了在提高查询效率的同时均衡插入和删除效率，可以尝试在树结构中存储索引数据。
其中数据的顺序性肯定是要进行保留，否则查询的时间复杂度将要上升到O(n)。而具有顺序性的树结构，最简单的便是二叉搜索树。
所谓二叉即子树的分支最多只有两个，搜索特性则保持了数据的顺序性。顺序性+两个分支，理论上与有序数组+二分查找有相同的查询效率，
即O(logN)的时间复杂度，但在极端情形（连续的插入的所有数据具有单调递增或递减特性）下会退化为线性链表，
此时时间复杂度将上升到O(n)。这种不平衡特性导致二叉搜索树也并非索引结构的良好选择。

5、平衡二叉搜索树（Balanced Binary Search Tree）
如果能在二叉搜索树的顺序性和二分查找的基础上增加平衡性，就能够解决二叉搜索树的极端不平衡问题。
AVL（Adelson-Velsky and Landis Tree）树和红黑树（Red Black Tree）都是自平衡的二叉搜索树，两者都可以通过
旋转保持树的平衡，查询效率稳定在O(logN)，但是这两种自平衡的二叉搜索树，无法控制树的高度，尤其在大数据量情形下，
树的高度增长明显，虽然时间复杂度是O(logN)，随着N增长越快，logN的值也越来越大。
这就意味着需要遍历更多树的层数，需要进行更多次磁盘I/O操作，整体的效率就会大打折扣。

6、平衡多叉搜索树（Balanced Multi-way Search Tree）
顺序性肯定要保持，否则查询的时间复杂度将退化为O(n)；平衡性也需要保持，否则在极端情况下退化为链表，时间复杂度也要上升到O(n)。
那么能否将原本的二叉转为多叉，将二分查找转为多分查找，应该是可以提高查找效率的。
二分查找时logN以2为底，三分查找时logN以3为底，在同样的数据量N下，对N取以3为底的对数自然是要比对N取以2为底的对数要小。
理论上来说，对于相同的数N取对数，底数越大，得到的对数越小，也就是说树的分支越多，同一数据量下树的高度就越低。
假设树的分支无限多，那么任何数据量下树的高度也就是层数基本就保持在2层，这相当于从另一种极端场景下退化成了线性链表。
另外树的分支很多的时候，单个节点所存储的数据量就越大。
树的满节点数与树的高度的关系公式为：n = 2^h - 1，其中h为树的高度，n为树的所有分支挂满节点时的总节点数。
如果总数据量为N，树的分支树为m，N不变的前提下，m增大，树的高度h（logₘN）减小，此时树的节点数n也减小，
同样的数据量N就会分担到更少的节点中存储，单个节点所存储的数据量就会增加。
而如果单个节点存储的数据量超过内存或磁盘页的容量，就需要分多次进行磁盘I/O，单节点数据量越大，磁盘I/O次数越多。
所以分支过多或分支过少都会使磁盘I/O次数增多，那么分支数的选择需要一个均衡点，这个均衡点即为磁盘单次I/O所能读取的最大数据量，
也就是计算机的磁盘页或磁盘块的数据容量。

平衡多叉搜索树又称为平衡多路搜索树，当然不一定只有三个分支，具体分支与磁盘块的大小和数据库引擎数据读取单元大小有关。
平衡多路搜索树叶可以简称为B树或B-树，整棵树每层有多个分支，也就是每层有多个节点用于数据存储。
B树作为索引结构时，树的节点中肯定要存储索引字段对应的值，这些索引字段值又通常被称为键，通过具体的键最终能定位到具体的数据行。
一棵树中拥有子树的节点称为非叶子节点，没有任何子树的节点称为叶子节点。
早期版本的B树的叶子节点和非叶子点都会存储索引字段值和对应的完整数据行。定位到了索引字段值，就能够找到对应的数据行。
但这可能导致相同的数据在多层节点中重复存储，每个节点的数据量较大，单个节点能容纳的键数减少，树的高度就会有所增加，
磁盘I/O次数也随之增加。单个节点的数据量较大，存储的键数较少，在范围查询时需要访问更多的节点和更多层级，效率低下。

这些问题的根结就在于每个键和键对应的数据行都一起存储，数据存储冗余导致查询效率低下，如果能分开存储或者只在必要的节点存储，
应该可以提高查询的效率。
B+树就从这个方面基于B树优化而来，B+树只在叶子节点中存储具体数据，非叶子节点只存储键的值，
也就是说非叶子节点只存储索引字段的值，叶子节点存储索引字段值+对应数据行。
这样在非叶子节点同样的存储空间能存储更多的键数，查询效率大大增加，尤其在范围查询时，可以减少访问层数和访问节点数。
B+树的叶子节点中存储的数据，在一级索引和二级索引上还有些差异。
在一级索引也就是聚簇索引（比如主键索引）中，叶子节点中存储的数据为索引字段值+具体的数据行。
在二级索引也就是非聚簇索引（比如唯一索引、普通索引、联合索引）中，叶子节点中存储的数据为索引字段值+对应的主键值。

现代主流数据库基本都是以B+树作为索引的主要结构，只在一些特殊场景时才采用其他数据结构来维护索引。

二、索引的设计和原理
从索引数据结构的变迁过程可以看到，一种良好的索引数据结构，除了要能提高数据查询效率外，也应当对于数据量有较好的支撑度。
查询数据的效率基于有序性时要高于无序性，数据结构也最好有自动平衡的功能以避免在极端情况下退化为线性数组或线性链表。
此外还要结合磁盘块的空间大小、磁盘I/O次数、单次磁盘I/O性能，尽可能减少磁盘I/O次数，比如InnoDB以16KB为默认数据页大小，
而一般的磁盘块空间大小为4KB，InnoDB的一页存储空间可以读取4块磁盘数据，再将具体数据只安排在叶子节点存储，
非叶子节点只存储索引字段值，这样能存储更多数据行的索引字段值，大幅度提高了查询尤其是范围查询的效率。
索引字段值所占空间与字段的类型和长度有关，比如int类型、varchar类型等各有差异，字段值所占空间可根据具体类型和长度计算。

三、索引字段的设计和优化
从索引数据结构的选择和优化过程可以看到，索引字段值的大小和数据行的大小决定着一个数据页能存储下的索引字段值和数据行有多少。
字段值所占空间越小，单位空间下能存储的索引字段值或数据行就越多，查询的效率就越高。但需要注意的一点是，数据库在查询时
所实际使用的索引由优化器自行选择，对于简单字段虽然所占空间少，但因为字段值的重复度太高，优化器可能不会进行索引扫描。
实际表字段设计中应当尽可能只提供必要长度，能够用简单类型尽量不用复杂类型，不过对于一些自定义输入性的业务字段比如名称等
要么在入库前校验好长度，要么考虑使用不限制长度的类型比如text，要么将长度设置大一点保证冗余性。但对于长度动态可变的类型比如
varchar等，即便没有存储数据，也同样占用空间，所以字段类型的选择和长度设置要结合业务需求弹性和索引效率两方面均衡考量。
