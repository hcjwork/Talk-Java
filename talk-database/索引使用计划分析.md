在MySQL中可以通过explain语句分析查询操作的数据扫描方式和索引使用情况，是检查索引是否正常应用的关键手段，
通过分析一个查询语句的具体索引应用情况，来判断索引是否失效、是否回表等关键信息，从而得到优化或调整的方向。
其他主流数据库比如Oracle、PostgreSQL、SQL Server等也支持explain分析，但可能在实际语法上有些差异。

这里以MySQL的explain分析为例，剖析下explain结果集的核心字段，各有什么关键属性或值。
例如，有一个`user`表，包含id、name、age、mark、city、email等字段。
其中id为主键，基于id有主键约束，主键约束也是唯一约束，主键要求唯一且非空；
其中email字段建立了普通索引idx_email，name、mark、city三个字段联合建立了复合索引idx_name_mark_city。

explain语句示例1：explain select email from user where email like '233%';
explain语句执行结果如下：
id	select_type	table	partitions	type	possible_keys	key	key_len	    ref	    rows	filtered	Extra
1	SIMPLE	    user	            range	idx_email	    idx_email	    259		1	    100	        Using where; Using index

explain结果集核心字段说明
1、type（关键性能指标）
访问类型，包含多种不同类型，是判断数据扫描方式是否全盘、是否覆盖索引、索引是否生效的关键字段。其包含的类型如下：

system：
这是const连接类型的特例，当表中只有一行时，这个类型出现。例如，使用主键或唯一索引的单行查询。
但实际测验中，使用主键或唯一索引的单行查询时type字段显示的是const而不是system。
又有说system是查系统表时出现比如select 12 from dual，实际测试中发现type字段直接为空，什么都没有。

const：
通过索引一次就能找到记录的查询，比如主键索引或唯一索引对应字段的等值查询。
实际测试中，上述说法属实，无论是主键索引还是唯一索引（非主键索引），索引对应字段等值查询时type字段显示的是const。
主键索引是一种特殊的唯一索引，唯一索引只需要对应字段的值唯一就行不要求非空，主键索引要求对应字段的值唯一且非空。
唯一索引是二级索引，其非叶子节点只存储索引字段值，用于查找导航，而叶子节点则存储的索引字段值和对应行的主键值，
因此通过索引字段值找到对应的主键值后还需要在主键索引中通过主键值定位到对应的具体数据行。
需要进行两次索引树的查找，因此二级索引包含有回表操作。非唯一索引的普通索引也是二级索引的一种。

eq_ref：
在连接查询中，使用主键或唯一索引进行查找。通常出现在使用非空的主键或唯一索引的所对应字段作为连接查询的关联字段。
只要是涉及到主键或唯一索引字段的，join联查或嵌套子查询，都会出现eq_ref。
实际测试：
①通过join连接查询，如果不通过on指定关联字段，两个表都会是全表扫描，type字段为ALL类型；
②通过join连接查询，并以on指定关联字段，如果两个表的关联字段都没有建立索引，则两个表都是全表扫描，type字段为ALL类型；
③通过join连接查询，并以on指定关联字段，如果两个表的关联字段其中一个有索引，但不是主键索引也不是唯一索引，建立索引的这张表
会使用到索引，对应type字段为ref类型，未建立索引的那张表对应type字段为ALL类型；
④通过join连接查询，并以on指定关联字段，如果两个表的关联字段其中一个有索引，并且索引是主键索引或唯一索引，建立索引的这张表
会使用到索引，对应type字段为eq_ref类型，未建立索引的那张表对应type字段为ALL类型；
由此可见，如果是高频关联字段，在关联的两个表都应当为该字段建立索引，如果不能无法主键索引或唯一索引，建立普通索引也能提高效率。

ref：
非唯一性索引扫描，返回匹配某个单一值的多行数据。非唯一性索引即非主键索引非唯一索引，也就是普通索引或联合索引。
实际测试：
①通过join连接查询，并以on指定关联字段，如果两个表的关联字段都没有建立索引，则两个表都是全表扫描，type字段为ALL类型；
②通过join连接查询，并以on指定关联字段，如果两个表的关联字段其中一个有索引，该索引为普通索引，建立索引的这张表会使用到索引，
对应type字段为ref类型，未建立索引的那张表对应type字段为ALL类型；
③通过join连接查询，并以on指定关联字段，如果两个表的关联字段其中一个有索引，该索引为联合索引，建立索引的这张表会使用到索引，
对应type字段为ref类型，未建立索引的那张表对应type字段为ALL类型；

给要关联查询的两种表的关联字段建立索引，能提高查询效率；以主键字段或唯一索引字段作为关联字段效率会更高。
如果是联合索引，并且筛选条件中筛选字段全覆盖索引字段，这时不是关联查询或子查询，explain结果集中type字段也为ref类型。

fulltext：
使用全文索引检索。这个很少用，适用于特殊场景。

rel_or_null：
类似于ref，但是添加了一个额外的搜索条件，即列可以为NULL。
ref只会查关联字段值非NULL的数据行，而rel_or_null对于关联字段值为NULL的数据行也会查询。
实际测试没有体现出来，两个表的关联字段都修改为允许NULL值，再次通过`join...on...`查询，
explain结果集中type字段显示为ref类型。
其实不用太关注rel_or_null和ref类型的差异，只需要知道rel_or_null类型也使用到了索引就行。

index_merge：
使用了索引合并优化方法，查询使用了两个或以上的单列索引来处理查询。
实际测试：
比如user表针对name、city两个字段分别建立了单列索引（即普通索引）idx_name和idx_city，where条件中同时筛选name和
city字段，例如：select * from user where name = 'jack' or city = 'a'
explain分析得到type类型为index_merge类型。
索引合并优化（Index Merge）是MySQL将多个单列索引的结果合并处理（交集/并集）的优化策略，主要包含两种方式：
Index Merge Intersection：多个索引的交集（AND条件，例如`WHERE a=1 AND b=2`）。
Index Merge Union：多个索引的并集（OR条件，例如`WHERE a=1 OR b=2`）。

unique_subquery：
结果依赖于单值子查询。子查询为IN的一个子句返回一个列的唯一值。
嵌套子查询时才会出现，而且是in子句的方式，in子句的查询结果子集只有一行一列数据。专门用于优化IN（子查询）且子查询字段
是主键或唯一索引的情况。此时MySQL会将子查询转换为高效的常量比较，类似ref访问，避免全表扫描。

index_subquery：
与unique_subquery类似，也是用于优化IN（子查询）语句效率的，但index_subquery是针对子查询字段为普通索引的情况。
结合unique_subquery和unique_subquer类型，确保in语句中查询字段包含主键字段或唯一索引字段，可以避免全表扫描。

range：
筛选字段是索引字段，只检索给定范围的行。常见于<, >, =, IN等操作符的查询。
针对索引进行范围扫描，但要注意防止索引失效。比如在操作符的左侧对索引字段进行计算。
如`select * from user where id + 10 > 30`，>符号左侧对id字段进行了计算，导致数据库放弃索引扫描而转为全表扫描。
只要操作符左侧只有纯粹的索引字段，操作符右侧无论计算多复杂、函数调用多深都会应用到索引扫描。

index：
全索引扫描，比全表扫描效率略高，因为索引的体量比全数据行小。
当查询语句里select子句后只出现索引字段，且where子句里不出现索引字段，此时进行全索引扫描，
explain结果集中type字段为index类型。因为不知道要扫描哪个索引树才能获取到预期结果，只好扫描所有的索引。
比如user表中id为主键字段email为普通索引字段，以下查询中会进行全索引扫描：
select id,email from user;
此查询语句并没有where子句，在select子句中查询的字段都是索引字段，explain结果集中type字段为index类型。


ALL：
全表扫描，未使用任何索引，性能最差。
比如使用联合索引时违背了最左前缀原则，导致联合索引失效，此时explain结果集中type字段为ALL类型，即表示全表扫描。
联合索引字段的顺序与最左前缀原则无关，只要最左侧的字段出现了就可以，不管是放在哪联合索引都会生效，
比如user表基于name和city字段建立了联合索引idx_name_city，以下查询中联合索引正常应用：
select * from user where city = 'a' and name = 'b';
此时explain结果集中type字段为ref类型，即基于索引进行等值匹配。

总结：
type字段的类型包含：system、const、eq_ref、ref、fulltext、req_or_null、index_merge、unique_subquery、
index_subquery、range、index、ALL。
其查询性能从高到底的顺序为：system > const > eq_ref > ref > fulltext > req_or_null > index_merge > 
unique_subquery > index_subquery > range > index > ALL。
index类型虽然不是全表扫描，但比全表扫描的性能也高不了多少，因此应当尽量让数据扫描的类型达到range类型，当然越往前靠
性能越好。
不过性能顺序靠前的类型其中有几种实际并不常见，比如system、fulltext、req_or_null。
比较常见的是const、ref、range、index、ALL等类型。
注意不要对索引字段进行函数调用、数字运算、隐式转换、前置模糊匹配等无法在索引结构中直接扫描到预期值的操作，否则将导致
数据库直接转为全表扫描，从而让索引失效。
对于查询字段覆盖了索引字段，但如果没有在where子句中显示应用索引，数据库不知道要扫描哪个索引，就会扫描全部索引，此时
数据扫描类型为index类型，这种情形下的查询效率只略高于ALL类型即略高于全表扫描。
所以应尽可能：①只查询索引字段 ②显示指定应用什么索引，即通过where子句、on子句、子查询等告知数据库要扫描的索引。
索引覆盖查询虽然能避免全表扫描，但如果不指定应用的索引是哪一个，会导致数据库扫描全部索引。另外索引覆盖并不限于联合索引，
对于单列索引如主键索引、唯一索引、普通索引都有索引覆盖的具体体现。而且即便是只查一个主键字段，如果没有显示指定所应用的索引，
通用会导致数据库扫描全部索引（而不是只扫描主键索引）。
看到type字段为index类型时，确实会应用索引，但扫描的是全部索引，所以效率不高。

2、key（关键字段）
显示实际使用的索引。可能不在possible_keys中，由优化器自行选择。

3、Extra（重要补充信息）
这是对索引使用情况的的重要补充，常见值及含义如下：
Using index：覆盖索引
Using where：server层过滤
Using temporary：使用临时表
Using filesort：额外排序操作
Using join buffer：使用连接缓存
Impossible WHERE：WHERE条件永远为false
Select tables optimized away：优化器已优化掉表访问

注意：看到`Using index`表示确实应用到了索引，但是否为全部索引扫描还需要结合type字段来分析。

4、其它字段
id：查询标识符，表示查询中SELECT语句的执行顺序。
select_type：查询类型。
table：访问的表名或别名。
partitions：匹配的分区信息，使用分区表时显示。
possible_keys：可能使用的索引列表，实际使用的索引不一定在此字段中展示，要看字段key。
key_len：使用的索引字节数。据此可以判断索引使用完整度。计算公式：各字段类型长度之和（需考虑字符集、是否可为NULL等）。
ref：索引的哪一列被使用。比如联合索引涉及到多列，有可能只是使用了其中的一部分。常见值有`const：常量值。列名：关联查询的列。func：函数结果`。
rows（`可关注`）：预估要读取的行数，是评估查询效率的关键指标。要读取的行数越多，查询效率越低。
filtered（`可关注`）：存储引擎返回数据在server层过滤后的百分比。可用于评估join性能（rows × filtered）。数值越小表示存储引起返回的无效数据越多。


从MySQL的explain索引执行计划分析，可以引申出一些查询优化方向：索引建立、索引合并、索引覆盖、避免索引失效、索引显示应用。
索引建立：
不使用索引时，数据库需要对表的全量数据逐一扫描，尤其是还有条件筛选时，需要对每一个数据行中对应字段进行比对分析，这种情况下
查询的效率基本取决于磁盘I/O性能和数据库工作线程模型，效率明显不足。而建立索引，二级索引只需要存储索引字段值和主键值，一级
索引即聚簇索引（比如主键索引）则会存储索引字段值和对应数据行信息，但无论哪种索引通常都具有顺序性，尤其是聚簇索引，其顺序性
与数据行的物理顺序性保持关联，当查询索引字段或使用索引字段筛选结果集时，能应用到索引数据从而避免全表扫描，能提高查询效率。

索引合并：
索引合并是数据库对于使用多个单列索引（即普通索引）进行查询结果筛选的优化，原本可能需要对每个单列索引分别筛选和回表，
数据库对每个单列索引字段筛选出的对应主键值取交集或并集，然后统一以取交集或并集后得主键值去扫描主键索引获取行数据。
如果多个单列索引字段是以and形式进行筛选，可以将多个单列索引替换为联合索引，能应用到等值匹配索引扫描，提高查询效率。
如果多个单列索引字段是以or形式进行筛选，使用联合索引还是单列索引则可能会扫描全部索引。

索引覆盖：
当一个查询语句只查询索引字段时，称作索引覆盖。
但如果没有指定筛选条件或者筛选条件中并未使用索引字段，数据库不知道要扫描哪个索引，就会转为扫描全部索引。但终究是使用到了
索引，能避免全表扫描，所以也算是查询优化的一种方式。
or操作符不会使索引失效，但如果查询字段只包含索引字段，会导致扫描全部索引，效率会有所下降。
但如果筛选字段全部是单列索引字段时，使用了or操作符，查询字段里包含了非索引字段，数据库反而会进行索引合并优化，查询效率
反而高于索引覆盖。（`特殊优化点`）
而如果筛选字段包含了非索引字段，即便只查询索引字段，数据库还是会扫描全表。

避免索引失效：
1、函数调用
如果是在查询字段中对索引字段使用函数，不会使索引失效；
如果是在筛选字段中对索引字段使用函数，会使索引失效；

总结：只有在筛选字段中对索引字段使用函数，并且查询字段包含非索引字段，才会使索引失效。

2、运算操作
查询字段只包含索引字段，筛选字段只包含索引字段，但在操作符左侧对于索引字段有进行运算，不会使索引失效。
查询字段只包含索引字段，筛选字段只包含索引字段，但在操作符右侧有进行运算，不会使索引失效。
查询字段包含非索引字段，筛选字段只包含索引字段，但在操作符左侧对于索引字段有进行运算，会使索引失效。
查询字段包含非索引字段，筛选字段只包含索引字段，但在操作符左侧对于索引字段没有进行运算，不会使索引失效。

总结：只有在筛选字段中在操作符左侧对于索引字段有进行运算，并且查询字段包含非索引字段，才会使索引失效。

运算操作包括算术运算、位运算等。

3、前置模糊匹配
查询字段包含非索引字段，筛选字段只包含索引字段，但对于索引字段进行前置模糊匹配，会使索引失效。
查询字段只包含索引字段，筛选字段只包含索引字段，但对于索引字段进行前置模糊匹配，不会使索引失效，但会转为全索引扫描。

总结：只有在筛选字段中对于索引字段进行前置模糊匹配，并且查询字段包含非索引字段，才会使索引失效。

4、NULL判断
查询字段包含非索引字段，筛选字段只包含索引字段，但对于索引字段进行NULL值判断，会使索引失效。
查询字段只包含索引字段，筛选字段只包含索引字段，但对于索引字段进行NULL值判断，不会使索引失效，但会转为全索引扫描。

总结：只有在筛选字段中在对索引字段进行NULL判断，并且查询字段包含非索引字段，才会使索引失效。

5、隐式转换
查询字段包含非索引字段，筛选字段只包含索引字段，但对于索引字段的值有隐式转换，会使索引失效。
查询字段只包含索引字段，筛选字段只包含索引字段，但对于索引字段的值有隐式转换，不会使索引失效，但会转为全索引扫描。

总结：只有在筛选字段中在对索引字段有隐式转换，并且查询字段包含非索引字段，才会使索引失效。

6、or操作
查询字段只包含索引字段，筛选字段只包含索引字段，但对于筛选字段用or操作符连接，不会使索引失效，但会转为全索引扫描。
查询字段包含非索引字段，筛选字段只包含索引字段，但对于筛选字段用or操作符连接，不会使索引失效，还会进行索引合并优化。
查询字段只包含索引字段，筛选字段包含非索引字段，但对于非索引字段用or操作符连接，会使索引失效。
查询字段包含非索引字段，筛选字段包含非索引字段，但对于非索引字段用or操作符连接，会使索引失效。
查询字段只包含索引字段，筛选字段包含非索引字段，但对于索引字段用or操作符连接，对于非索引字段用and操作连接，不会使索引失效，还会进行索引合并优化。

总结：只有在筛选字段包含非索引字段并对非索引字段用or操作符连接，不管查询字段是否包含非索引字段，都会使索引失效。

7、违背最左前缀原则
查询字段包含非索引字段，筛选字段包含非索引字段，但对于索引字段符合最左前缀原则，不会使索引失效。
查询字段只包含索引字段，筛选字段包含非索引字段，但对于索引字段符合最左前缀原则，不会使索引失效。
查询字段只包含索引字段，筛选字段只包含索引字段，但对于索引字段违背了最左前缀原则，不会使索引失效，但会转为全索引扫描。
查询字段包含非索引字段，筛选字段只包含索引字段，但对于索引字段违背了最左前缀原则，会使索引失效。

总结：只有在筛选字段中对索引字段的使用违背了最左前缀原则，并且查询字段包含了非索引字段，才会使索引失效。

8、not in操作
查询字段包含非索引字段，筛选字段只包含索引字段，但对于索引字段使用了not in操作符，会使索引失效。
查询字段只包含索引字段，筛选字段只包含索引字段，但对于索引字段使用了not in操作符，不会使索引失效，但会转为全索引扫描。
查询字段包含非索引字段，筛选字段只包含索引字段，但索引字段是主键字段，对于索引字段使用了not in操作符，不会使索引失效，而且转为索引范围扫描。
查询字段只包含索引字段，筛选字段只包含索引字段，但索引字段是主键字段，对于索引字段使用了not in操作符，不会使索引失效，但会转为全索引扫描。

总结：只有在筛选字段中对索引字段使用了not in操作符且索引字段不是主键字段，并且查询字段包含了非索引字段，才会使索引失效。

避免索引扫描降级和优化索引扫描：
1）对于索引失效场景，当查询字段覆盖索引时，会保证索引得到应用，但会扫描全部索引，效率也会降低，
因此应当尽量避免如下场景：
①对筛选字段中的索引字段进行函数调用。
②对筛选字段中的索引字段进行算术运算或位运算。
③对筛选字段中的索引字段进行前置模糊匹配。
④对筛选字段中的索引字段进行NULL判断。
⑤对筛选字段中的索引字段进行隐式转换。
⑥对筛选字段中的索引字段进行`or`操作符连接。
⑦对筛选字段中的索引字段违背了最左前缀原则。
⑧对筛选字段中的索引字段使用`not in`操作符。
2）对于筛选字段只包含索引字段的场景，如果筛选字段要用or操作符连接，在查询字段中加上非索引字段，可以从全索引扫描优化优化为索引合并扫描。
3）对于筛选字段只包含索引字段的场景，如果索引字段是主键字段，在查询字段中加上非索引字段，可以全索引扫描优化成索引范围扫描。

索引显示应用：
在筛选字段或关联字段中显示应用索引字段，可以从全索引扫描或全表扫描优化成更高效的索引扫描方式。
但注意不要让索引失效，尤其在查询字段中包含有非索引字段时，避免使用or、not in、!=、null判断等操作符。
筛选字段和关联字段尽量使用主键字段，这样不需要进行主键回表操作，只需要扫描一次索引就能找到数据行。
在`not in`操作中如果使用的是主键字段，能保证索引不会失效。
还有对于所谓的索引失效场景，如果查询字段只包含索引字段，也就是覆盖索引，索引不会失效，最多是降级扫描方式到全索引扫描。
只有在查询字段包含有非索引字段时，才会有出现索引失效的可能。因为覆盖索引场景下，数据库可以直接从索引扫描中拿到预期数据，
也就没必要去查表的全量数据了。


数据结构和算法对程序开发的启迪与指导作用。