零拷贝（Zero-Copy）技术是一种通过减少数据拷贝次数来提升I/O性能的关键技术，常用于高并发场景下网络传输和大文件处理。
零拷贝不是说完全不拷贝，而是尽量减少大数据在用户态和内核态之间的复制次数，以降低CPU和内存的开销，缩短数据拷贝耗时。

传统的文件传输过程（以读取文件数据并通过网络发送为例）：
1、用户程序执行read(file)系统调用，让内核从磁盘中读取数据。
2、内核通过DMA从磁盘中读取数据到内核缓冲区中。
3、内核通过CPU拷贝，将内核缓冲区中的数据拷贝到用户程序缓冲区。
4、用户程序执行write(socket)系统调用，准备将数据写入网络连接中进行传送。
5、内核接收到用户程序的网络发送调用请求，通过CPU从用户程序的缓冲区中将数据拷贝到内核的Socket发送缓冲区。
6、内核通过DMA将Socket发送缓冲区中的数据拷贝到网卡队列。
7、网卡把数据发送网络中。

用户程序缓冲区其实就是用户程序的运行内存中缓冲空间，内核就是操作系统，用户程序与硬件（CPU、磁盘、网卡等）的交互需要通过
操作系统做中转。

从上面的文件传输过程可以发现：
1、用户程序执行了2次操作系统调用，一次read(file)系统调用，一次write(socket)系统调用。
2、用户空间到内核空间历经了2次CPU拷贝。
3、内核空间到硬件历经了2次DMA拷贝。
4、用户态和内核态历经了4次切换：用户态->内核态、内核态->用户态、用户态->内核态、内核态->用户态。

多次系统调用、多次用户态和内核态的上下文切换、多次CPU拷贝、多次DMA拷贝，在这个文件传输流程中，数据被多次读写流转，占用了
大量的CPU和内存资源。其实有一部分流程是可以省略的，比如：
1、多次系统调用可以合并为一个。read(file)和write(socket)可以合并为sendfile(file,socket)一个系统调用，把读取文件
和发送到网络中合并为一个。
2、两次CPU拷贝可以省略。读取文件数据和发送数据到网络中合并为一个系统调用后，内核通过DMA从磁盘中读取数据后存于内核缓冲区，
此时不需要拷贝到用户空间，而是直接通过DMA将内核缓冲区中的数据拷贝到网卡缓冲区。
3、四次用户态和内核态可以缩减为一次。读取文件数据和发送数据到网络中合并为一个系统调用后，数据只在内核和硬件中流转，用户态
只在第一次sendfile(file,socket)系统调用时切换到内核态，而不用再切换回用户态。

上面这个优化流程就是基于sendfile系统调用实现的，Java的FileChannel.transferTo便是通过JVM底层的sendfile调用实现零拷贝。

除了sendfile系统调用实现文件传输流程优化，还可以基于`mmap+write`内存映射和`DMA Scatter/Gather`硬件加速来实现。
网卡支持分散-聚集（Scatter-Gather）DMA 操作，可直接从多个内核缓冲区收集数据发送，能完全避免CPU参与数据拷贝。
`mmap+write`内存映射则是将文件映射到用户空间的虚拟内存上，用户程序发起mmap(file)系统调用和write(socket)系统调用时
直接操作内核缓冲区，可避免拷贝到用户空间。

网络I/O与磁盘I/O：
I/O指的是以用户程序内存空间为参照点的描述数据传输方向和过程的名词。I是Input输入，O是Output输出。
网络Input，就是将数据从网络中传输到用户程序内存中，相对用户程序内存而言是由数据从外部进入自己内部。
网络Output，就是将用户程序内存中的数据传输到网络中，相对用户程序内存而言是由数据从内部送出到外部。
磁盘Input，就是将数据从磁盘中读取到用户程序内存中，相对用户程序内存而言是由数据从外部进入自己内部。
磁盘Output，就是将用户程序内存中的数据存储到磁盘中，相对用户程序内存而言是由数据从内部送出到外部。
