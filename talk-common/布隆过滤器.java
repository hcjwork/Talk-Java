布隆过滤器（Bloom Filter）是一种基于位数组（Bit Array）的以空间换时间的高效率的数据结构，用于判断元素是否在数据集合中。
（1MB=1024KB，1KB=1024Byte，1Byte=8Bit，即1字节=8位。位数组也称为比特数组。）

布隆过滤器主要由位数组和哈希函数两部分组成，一个布隆过滤器假设有一个长度为m的位数组、有k个哈希函数，其工作原理大致如下：
1、添加元素
添加元素时，使用k个哈希函数分别计算新元素的k个哈希值，根据这k个哈希值将位数组中对应的位设置为1。
注意：
使用多个哈希函数是为了降低元素哈希值的冲突。
k个哈希函数计算新元素的哈希值，最多得到k个不同的哈希值，不同的有可能少于k个。
2、查询元素
查询元素时，也是使用k个哈希函数分别计算新元素的哈希值，最多得到k个不同的哈希值，再查看位数组中对应位。
如果对应位都是1，则该元素可能存在于位数组中，因为对应位为1可能是其他元素覆盖导致的，所以不能直接判断为已存在，只能算可能存在。
如果对应位中有一位是0，则该元素肯定不在位数组中，因为一位为0，说明没有元素覆盖过，那当前查询的元素也就自然不在位数组里。

从布隆过滤器的元素添加和元素查询的工作原理可以分析出：
1、查询元素时可能会误判为已存在。
2、元素如果不存在会很明确，不会误判为不存在。
3、不同的元素可能会在相同的位上同时覆盖为1，所以没法进行元素删除，只要删掉一个位上的1就会导致所有与这一位相关的元素全被删除。
4、不同元素通过k个哈希函数计算可能会得到相同的哈希值，这就导致位数组上位的值会可能被多个元素覆盖为1，也就无法分清具体哪些
元素已经存在，只能分辨出哪些元素不存在。

一般的布隆过滤器是不支持元素删除的，但可以通过`Counting Bloom Filter`变种实现，即记录每一位被覆盖为1的次数，每次删除
元素时，对应位的1的覆盖次数减1，直到对应位的值变为0时表示已经删除了所有与该位相关的元素。

布隆过滤器最大的特性就是可以利用非常小的空间（位数组）高效地判断出目标不存在于数据集中。
利用这个特性可以实现缓存判断、黑名单、白名单、节点列表等场景。
通过快速判断目标元素不存在，从而缩短后续流程，提前返回准备好的降级响应或直接拒绝提供服务。

布隆过滤器常见的应用场景
1、缓存查询
快速判断数据是否不存在于缓存中，如果不存在则直接返回不存在。
（缓存穿透：查询缓存数据时发现不存在，但不确定数据是没有存入过缓存还是本来就没有这个数据，因此需要查询数据库，
此时对应的查询负载就穿过缓存透传到了数据库上。）
2、邮件过滤
维护一个垃圾邮件名单，判断邮件地址是否已存在，如果判断不存在则予以放行。
（这种场景下维护黑名单要比维护白名单简单）
3、URL去重
判断新的URL是否已经存在，不存在说明是第一次访问，针对性处理后添加到布隆过滤器中。

布隆过滤器因为其特性对于元素存在可能误判，这个误判率与位数组的长度m和哈希函数个数k紧密相关。
假设有元素e，经过哈希函数h计算后得到哈希值h(e)，那么哈希函数h计算后元素e对应的位数组中的索引为(h(e) % m)位。
以元素经过哈希函数得到哈希值后，对位数组的长度取模，即找到元素对应位数组中的哪一位，由此可知，位数组的长度m越大误判率
就越低，因为分散程度更高，此时不同元素的冲突程度就越低，但长度增加会使位数组所占空间增大。
每一个哈希函数以元素为参数计算后得到一个哈希值，k个哈希函数计算后就得到k个哈希值，当k增大时，可以覆盖的位数组的位也就越多，
误判率会有所降低，但其实位数组覆盖范围并不会一直增多，误判率也不会一直降低。误判率会随着k增大先降低后升高。
对于元素e，一个哈希函数计算出一个哈希值，当函数越来越多，一开始哈希值的种类增加，但逐渐会有一些函数
计算出相同的哈希值，此时哈希值的种类增加缓慢。而实际中元素e的值又在不断变化，这会导致不同元素所计算的哈希值冲突程度增加。
所以随着哈希函数个数k的不断增加，布隆过滤器的误判率会先降低后增加，存在一个最优解，通常k不会超过20。

实际上误判率p与位数组长度m、哈希函数个数k有关系公式为：p ≈ (1 - e^(-k*n/m))^k，其中n是预期要插入的元素数量。
最优哈希函数数量：k_optimal = (m/n) * ln(2) ≈ 0.693 * (m/n)。
当使用最优哈希函数数量k时，最小误判率为：p_min ≈ (0.6185)^(m/n)。

因为要使用哈希值对位数组长度取模，所以对元素求哈希值后通常要取绝对值（比如Math.abs(hash(e))），以避免位数组索引越界。
哈希值计算与数组索引取模是很常用的技术手段，其中如何使哈希值分布更均匀是最关键的一环。
自定义实现中可以使用加密哈希函数或加盐计算，可以让哈希值的分布更加均匀。

自定义实现布隆过滤器需要考虑诸多边界条件，要平衡空间占用、误判率和判断性能，推荐使用成熟的布隆过滤器组件或工具，比如
`Google Guava`库的布隆过滤器。

个人感悟：
0/1和是/否，不仅可以作为技术实现的参考方向，比如位数据结构、字段值null与非null、删除状态0与1等。
也可以作为一个通用性的方案基石，比如市场调研选项的是与否、评价选项的是与否。
还可以作为翘起思维方式的基点，比如无法判断是但可以判断否、难以判断不是但容易判断非否，满足条件的正向思考情形复杂时考虑
反向情形，不确定这样做会不会有效果但可以确定不这么做会有什么不利结果。
从0/1和是/否上思考，可以明晰哪些可做和哪些不可做，是正向思维和逆向思维的元初形态。

