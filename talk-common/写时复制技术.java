写时复制，Copy-On-Write，是一种资源管理技术，只有在真正修改数据时才进行数据复制，这样能大幅度提高性能并减少资源消耗。
当线程都是执行读操作时，所有线程共享原始数据；当有线程执行写操作时，内核基于原始数据页复制出一个新的数据页，写线程在新数据页
上进行数据修改，而其余的读线程依旧共享原始的旧数据，当写操作执行完成，内核通过指令通知所有CPU将修改后新数据页刷新到缓存中。

这个过程的主要核心在于写操作时的数据复制和数据修改后的内存可见性保证。
通过复制后的新数据页与原数据隔离来实现并发安全，数据修改后将新的数据页刷到CPU缓存中，原始数据的引用指向新数据，
其他线程再次访问原始数据时会访问到刷新后的新数据，原来的旧数据确定没有引用后会被GC回收。

虽然通过这种写时复制的方式提高了并发性能、减少了资源消耗，但只适用于读多写少的场景，写操作竞争激烈时，数据复制频繁性能会降低。
频繁修改也可能导致内存出现碎片化，另外就是数据的实时性，读操作可能看到旧数据，数据是弱一致性的，只能实现最终一致性。
频繁的数据复制，也会加大垃圾回收的任务量。

资源消耗与性能优化需要做一个平衡，但对于读多写少的场景，写时复制技术还是比较契合的，像Java的CopyOnWriteArrayList/Set、
数据库的MVCC快照版本隔离、Docker镜像分层创建、Linux进行的fork实现等，都是写时复制技术的经典应用。
比如CopyOnWriteArrayList通过volatile来保证数据读写的内存可见性。

为了保证并发安全，写操作通常都会加写锁，写锁一般是互斥锁，其他线程对于同一数据无论是读还写都会被阻塞隔离，这种加锁方式会
降低程序性能，因为涉及到了线程阻塞唤醒、线程上下切换等内核操作。而写时复制通过新数据页进行隔离而不用加锁，其他线程的读操作
依旧可以顺畅地共享同一数据，程序的并发性能得到了提升。但由于复制数据页和刷新数据页需要内核调用参与，写操作竞争如果比较
激烈就会降低整体性能，内存、磁盘等资源也会增加消耗，垃圾回收的工作也会增加，因此写时复制基本都是用于读多写少的场景，而且
需要容忍一定的数据延迟性（即数据修改是弱一致性的，并非强一致性）。
如果是写操作多的场景，通常采用锁机制或CAS来保证并发安全。
