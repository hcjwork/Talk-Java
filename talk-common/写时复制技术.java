写时复制，Copy-On-Write，是一种资源管理技术，只有在真正修改数据时才进行数据复制，这样能大幅度提高性能并减少资源消耗。
当线程都是执行读操作时，所有线程共享原始数据；当有线程执行写操作时，内核基于原始数据页复制出一个新的数据页，写线程在新数据页
上进行数据修改，而其余的读线程依旧共享原始的旧数据，当写操作执行完成，内核通过指令通知所有CPU将修改后新数据页刷新到缓存中。

这个过程的主要核心在于写操作时的数据复制和数据修改后的内存可见性保证。
通过复制后的新数据页与原数据隔离来实现并发安全，数据修改后将新的数据页刷到CPU缓存中，原始数据的引用指向新数据，
其他线程再次访问原始数据时会访问到刷新后的新数据，原来的旧数据确定没有引用后会被GC回收。

虽然通过这种写时复制的方式提高了并发性能、减少了资源消耗，但只适用于读多写少的场景，写操作竞争激烈时，数据复制频繁性能会降低。
频繁修改也可能导致内存出现碎片化，另外就是数据的实时性，读操作可能看到旧数据，数据是弱一致性的，只能实现最终一致性。
频繁的数据复制，也会加大垃圾回收的任务量。

资源消耗与性能优化需要做一个平衡，但对于读多写少的场景，写时复制技术还是比较契合的，像Java的CopyOnWriteArrayList/Set、
数据库的MVCC快照版本隔离、Docker镜像分层创建、Linux进行的fork实现等，都是写时复制技术的经典应用。
比如CopyOnWriteArrayList通过volatile来保证数据读写的内存可见性。

为了保证并发安全，写操作通常都会加写锁，写锁一般是互斥锁，其他线程对于同一数据无论是读还写都会被阻塞隔离，这种加锁方式会
降低程序性能，因为涉及到了线程阻塞唤醒、线程上下切换等内核操作。而写时复制通过新数据页进行隔离而不用加锁，其他线程的读操作
依旧可以顺畅地共享同一数据，程序的并发性能得到了提升。但由于复制数据页和刷新数据页需要内核调用参与，写操作竞争如果比较
激烈就会降低整体性能，内存、磁盘等资源也会增加消耗，垃圾回收的工作也会增加，因此写时复制基本都是用于读多写少的场景，而且
需要容忍一定的数据延迟性（即数据修改是弱一致性的，并非强一致性）。

写时复制其实是为了增加读操作的性能的，写操作复制和修改数据时也会加锁阻塞其他写操作，所以不适合频繁写的场景。
如果是写操作多的场景，通常采用锁机制或CAS来保证并发安全。

CopyOnWriteArrayList的缺陷：
        - 每次修改操作（add/set/remove等）都会创建底层数组的新副本
- 旧数组不会被立即回收，导致内存占用翻倍
- 写操作需要完全复制数组，时间复杂度为 O(n)
- 复制过程会加锁，阻塞其他写操作
- 不适合频繁修改的场景
- 弱一致性迭代器 - 迭代时看到的是创建迭代器时的数组快照
- 无法实时反映后续修改
- 数组复制成本与元素数量成正比
- 当元素数量很大时（如10万+），每次修改都会导致显著性能下降
