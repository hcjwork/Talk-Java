请求从客户端发送到服务端接收请求后处理，最后到客户端接收到服务端发送的响应。这个过程的全流程节点如下：
客户端发送请求 -> 网络传输 -> 服务端接收到请求 -> 解析请求数据 -> 执行业务处理 -> 组装响应数据 -> 服务端发送响应 -> 客户端接收到响应。
全流程可以分为两个部分：网络传输、服务处理。
网络传输包含两个部分：请求从客户端传输到服务端、响应从服务端传输到客户端。

请求从客户端发送到服务端接收这个阶段
1）首先请求要通过网络协议发送，那么网络带宽必然影响着请求数据发生的效率，但网络带宽的选择和布置不属于程序开发层面的东西。
2）其次是网络协议，采用什么样的协议有说法，根据不同的业务场景来，像物联网业务可能采用MQTT协议，
Dubbo服务架构中可能采用Dubbo协议，还有些自定义的特殊协议，比如MySQL的数据库协议等，此外就是通用性的HTTP或HTTPS协议。
3）如果需要使用的是非通用协议，那就只能按照约定来。
如果是使用通用性的协议，HTTPS协议因为有加密所以更安全，但性能相比HTTP协议略低。
一些常用的协议有其默认端口，比如HTTPS协议和HTTP2/3的默认端口为443，HTTP协议的默认端口为80，SFTP协议的默认端口为22，
MySQL数据库协议的默认端口为3306，Oracle数据库协议的默认端口为1521，PostgreSQL数据库协议的默认端口为5432，
Redis的默认端口为6379，SSH的默认端口为22，TELNET的默认端口为23等。
4）网络协议选定后，看网络协议支持哪些类型的数据格式，比如二进制格式的、JSON格式的、XML格式的、自定义格式的，选择二级制格式
时的序列化与反序列化效率会相对更高。
5）数据格式选定后，要尽量缩减传输的数据量，不必要传递的就不传，比如去除不必要的字段、使用占用空间更少的字段类型。
6）如果已经无法再删减，都是必要数据，可以考虑压缩后传输，但要注意选用高效率的压缩算法，因为压缩后虽然传输快了，但接收方的解压
需要耗时；另外如果数据量过大，可以考虑分页传输或分块传输。


服务端接收到请求到准备好响应这个阶段
1）数据到了，以I/O多路复用模型或AIO模型提高网络数据接收效率。
2）采用什么方式将数据拷贝到内存中也有说法，可以使用零拷贝技术减少数据在用户态和内核态间的拷贝次数以提高拷贝效率。
3）数据从网络拷贝到内存中后，如果是压缩后的需要解压，解压后需要按照约定的数据格式进行解析，也就是反序列化。反序列化可以选择
高效的反序列化算法。
4）如果是比较复杂的任务，可以使用多线程比如线程池来分片处理，或者交给异步变成处理如子线程或者消息队列。
5）并发竞争激烈时要使用锁保障并发安全，尽量使用无锁化（比如CAS、原子类、MVCC等）代替互斥锁（比如synchronized、ReentrantLock、表锁）等。
6）涉及到数据查询时，先查本地缓存、再查缓存数据库、最后查数据库，数据结果集比较大考虑分页查询或只查必要字段或最少范围数据行。
本地缓存可以使用Caffeine替换ConcurrentHashMap，缓存数据库可以选用Redis、Memcached等。
7）使用更高效的关键字，更高效的算法，采用批量操作代替循环单操作。
8）缓存尽量采用简单结构，复杂结构和大数据量考虑分片存取。
9）合理建立索引提高数据库查询性能，尽量只查索引字段，避免索引失效。优化SQL语句，减少资源消耗。
10）减少静态字段的定义以缩短GC停顿时间，及时释放资源池和资源连接避免内存泄漏而导致GC频次增加甚至出现OOM异常。
减少大对象的创建，尽量复用变量，减少动态代理对象的创建，使用对象池复用对象，使用连接池复用连接，使用线程池复用线程。
11）远程服务调用时，选择合理的负载均衡算法避免服务负载倾斜；配置熔断和降级兜底服务调用异常，避免异常蔓延。
12）通过限流算法或限流框架控制请求负载在系统可承受范围内，避免服务崩溃。
13）通过定时任务或消息队列形式解耦流程，缩短主流程响应时间。
14）只查询和组装必要的数据，减少响应数据量，比如只查询和组装必要字段。
15）采用高效的序列化方式，采用高效的数据压缩算法，将多个文件打包整理。

响应从服务端到客户端这个阶段，与请求从客户端到服务端这个阶段类似。



