我一直在探索，对于影响Java程序性能的因素有哪些，可能目前只能说出一部分来，后续如果另有心得，也可以往下继续加。
这里说的Java程序当然指的用Java语言编写的后端应用服务，
不管对接的是浏览器、其他系统服务、小程序、H5页面、移动APP还是别的什么服务调用方，就统称为前端。

从前端发起服务调用，到网络传输，到Java服务接收服务请求，到业务逻辑处理，到数据增删改查，到响应准备，
到网络传输，到前端接收响应。一整个调用链路里，能否分出哪些关键环节，
能够清晰表示，其对应的某些要素，对服务请求响应的链路性能有比较明显的影响的。

现从前端发起请求到最后前端接收到响应，尝试分析每个关键环节对调用链性能的影响。
1、前后端之间的数据传输
前端准备好要传输的数据，按照应用层的某种通用协议（比如HTTP/HTTPS协议）将数据通过网络传递给Java后端服务。
但是前端所在的机器往往与Java后端服务所在的机器不同，甚至不在同一片局域网中，不同的机器在不同的网络中怎么就能无障碍交互数据？
这是由物理设备结合网络协议实现的。
比如我们日常生活用到的物理设备如路由器、交换机、光纤、网线等，在其中发挥了非常重要的中转作用。
前端准备的数据，被转换成二进制或其他形态，通过应用层到传输层到链路层再到物理层。不同网络中的两台机器，通过交换机等设备转成同一个网段，
然后通过网线或光纤传递原始数据。
所以简单说来，从前端请求后端服务是，数据流转路径为：数据 -> 前端机器的应用层 -> 前端机器的传输层 -> 前端机器的链路层 -> 前端机器的物理层 ->
后端机器的物理层 -> 后端机器的链路层 -> 后端机器的传输层 -> 后端机器的应用层。
而后端服务处理好请求后返回响应数据，数据流转路径则与来时相反。
每一层的网络协议都不同，由应用层到物理层，每下一层就要包装成新的一层所约定的数据格式，
而从物理层到应用层，每上一层就要解析成新的一层所约定的数据格式，
每一层的包装工作称为粘包，每一层的解析工作称为拆包。
网络传输中性能损耗主要就在于粘包拆包工作。
但不同层次的网络协议各不相同，也难以用一种协议统揽全部层次的数据传输，毕竟物理的和虚拟的也没法用同一标准衡量，
那么粘包拆包的工作就无法避免了。
是否可以从其他方面进行改善呢？
虽然每一层都有协议，但具体实现有不同，不同实现有着不同优势，可以选择不同的协议实现。
而具体的协议实现也有迭代升级，比如去除某些冗余配置、使用更高效率的配置代替已有配置等。
选择了具体的协议实现，其对应的配置也可以按需调整。
此外还能从要输出的数据本身进行优化，比如流的形式传输、数据压缩后传输等。

总结下：具体协议的选择、数据格式的选择、数据压缩、数据分块传输、SpringBoot配置调整（http协议、web容器等）。

具体协议的选择：
例如传输层根据业务需求不同选择TCP或UDP或其他协议，TCP可靠性高但效率低，UDP效率高但可靠性低。
例如选择协议升级版本，如选用http2替代http1。

数据格式的选择：
例如使用Protobuf替代JSON。

数据压缩：
例如使用gzip等压缩算法压缩数据块。

数据分块传输：
例如将大数据块拆分成多个小数据块，分块传输。

SpringBoot配置调整：
例如开启http2协议支持。
例如调整web容器（如tomcat/undertow/jetty）的并发线程数、文件传输大小、缓冲区大小等；
像undertow默认不限制线程数，而tomcat和jetty的默认最大线程数是200。

2、前端请求转发

3、后端服务网关

4、后端Web容器

5、后端服务处理
1）使用缓冲区进行IO读写
2）批量数据分片用线程池处理
3）文件读写直接使用零拷贝
4）本地缓存+内存数据库缓存
5）ThreadLocal减少线程竞争
6）使用ReentrantLock或LockSupport代替synchronized
7）使用无锁编程代替线程互斥访问
8）使用数据库连接池
9）变量复用和大对象拆解降低GC频次和GC停顿时间
10）资源及时关闭避免内存泄漏
11）采用并行收集器提高GC效率
12）减少静态变量的定义，降低GC时间
13）减少共享变量的定义，减少线程竞争

6、后端数据查询与变更

7、其他中间件




