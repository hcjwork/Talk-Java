回溯，顾名思义，就是要利用到前面的数据或已使用过的数据作为某种计算条件的基准。
但这么说也很抽象，还是先从一个经典的组合问题说起吧。

LC77.组合
问题描述：
给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。数字的组合不要求顺序。
示例 1：
    输入：n = 4, k = 2
    输出：[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4]]
示例 2：
    输入：n = 1, k = 1
    输出：[[1]]
提示：
    1 <= n <= 20
    1 <= k <= n

以其中示例1中条件来说，n = 4，k = 2，从1-4有1、2、3、4四个整数，如果组合为2位数，可以穷举出来有：
12、13、14、23、24、34，一共是6种，如果用代码实现，则可以通过2层for循环得到，例如：
List<Integer> list = new ArrayList<>();
for (int i = 1; i <= 4; i++) {
    for (int j = i + 1; j <= 4; j++) {
        list.add(Integer.parseInt(i + "" + j));
    }
}
确实，当k较小时，可以直接通过嵌套k层for循环来解决，但如果k为100呢，光是嵌套100层for循环都写得够呛，还可能计算出错。

那有没有更好的通用方法来解决这个数字组合问题？有，回溯算法便非常适用于数字的排列或组合问题。
回溯算法也是基于嵌套for循环做的优化，通过前面的数据或已使用过的数据作为分支剪除依据，减少不必要的计算以提高效率。
回溯算法使用递归来遍历和组合，但其实也相当于是嵌套的for循环，只不过是以递归的形式呈现。

逻辑树分析


那这个递归该怎么写？
可以从这三个方面考虑：递归方法的参数和返回值、递归的终止条件、单层递归的处理逻辑。
1、确定递归方法的参数和返回值
  n和k肯定是要的，
  List<List<Integer>>也要，这是返回结果，其实就是个二维数组，
  List<Integer>也需要，每一个组合需要由k个数字拼起来，做临时存储用
  startIndex，1~n的数字的遍历起始位置，不能重复使用数字
2、确定递归方法的终止条件
  数字组合达到k位就可以加入到结果集中，然后退出递归
3、单层递归的处理逻辑
  1）遍历的数字要加入临时集合；
  2）然后从这个数字对应位置的下一位往后到n遍历，与当前数字进行组合。这一步就得调递归方法了。
  3）递归方法退出来了，说明已经是达到k位的数字组合，但需要把最后一位给去掉，不然后面的数字拼不成k位，
  例如预期要拼12、13、14，当前数字是1，递归往下遍历是2、3、4，已经拼成了12，需要延用数字1，把2去掉换成3组合成13。

具体代码示例：
public List<List<Integer>> combine(int n, int k) {
    List<List<Integer>> resultList = new ArrayList<>();
    List<Integer> list = new ArrayList<>();
    // 初始遍历位置从第1个数字开始
    backtrack(n, k, 1, resultList, list);
    return resultList;
}

private void backtrack(int n, int k, int startIndex, List<List<Integer>> resultList, List<Integer> list) {
    if (list.size() == k) {
        // 已经满足组合的位数要求了
        resultList.add(new ArrayList<>(list));
        return;
    }
    // 从startIndex开始遍历
    for (int i = startIndex; i <= n; i++) {
        // 把i位置的数加入数字集合
        list.add(i);
        // 往下一层遍历，起始位置往后延一位
        backtrack(n, k, i + 1, resultList, list);
        // 退出了递归，则去掉后面一位，好拼接其他数字
        // 例如预期要组合出：12、13、14，第1次组合成12后退出递归，此时list中是12，需要把2去掉，把3放进去组合成13
        list.remove(list.size() - 1);
    }
}