双指针常用于两个数据集的合并、滑动窗口的边界、链表的中心定位（快慢指针）、最长连续一类的边界扩展。
例如最长连续递增序列、最长连续回文子串，对于出现最长连续的关键词，就可以尝试双指针来解决问题。

以求最长连续回文子串为例，回文就是从左到右读和从右到左读完全一样，那么这个回文子串一定是中心对称的。
只不过这个中心可能是某个字符，也可能是某两个字符的间隙，因为这个子串的字符数可能是偶数可能是奇数。
所以要把这两种情况都计算下取最大的。
怎么计算呢？既然是对称特性，那么从中心字符或中心的相邻字符开始，
同时往两边扩散比较两个字符是否相同，如果相同就继续扩散，直到两边对应位置的字符不相同。
这个过程就涉及往两边同时扩散遍历，那就至少需要两个遍历指针。
假设往左边扩散遍历的定义为left，往右边扩然遍历的定义为right，
以当前i位置的字符为中心或以i和i+1位置的两个字符为中心，扩散比对的伪代码示例如下：
int maxLength = 0;
for (int i = 0; i < str.length(); i++) {
    // 以i字符为中心，这是计算回文子串字符数为奇数的情形
    int len1 = getMaxLength(str, i, i);
    // 以i和i+1字符为中心，这是计算回文子串字符数为偶数的情形
    int len2 = getMaxLength(str, i, i + 1);

    // 更新最大长度
    maxLength = Math.max(maxLength, Math.max(len1, len2));
}
public static int getMaxLength(String s, int left, int right) {
    // 从中心字符开始，往两边扩散遍历，不越界且对应位置字符相同，就继续扩散
    while (left >= 0 && right <= s.length() - 1 && s.charAt(left) == s.charAt(right)) {
        left--;
        right++;
    }

    // 因为最后一次比较相等还走了一回循环，出了循环已经是多往两边走了一次，所以计算回文长度需要在左右指针范围上-2
    return right - left + 1 - 2;
}
