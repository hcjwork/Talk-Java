回文子串指的是正向读反向读完全一样的字符串，
要判断一个字符串是否为回文的，只需要找到字符串的中心，然后同时往外找字符两两比较，
如果包括中心在内的两两比较全部相同就是回文字符串。

比如用一个left指针代表向左找下一个字符，用一个right指针代表向右找下一个字符，那么
当str.charAt(left) == str.charAt(right)时表示这两个对称位置相同，那么left~right范围上的字符串就是回文字符串。
继续往两外找下一个字符，就需要left--和right++。
因为left要往左找，往左的字符索引更小；right要往右找，往右的字符索引更大。
left和right指针都是不断往外扩展的，所以要进行越界判断，不能超过原字符串的边界。

另外需要考虑的点是，字符串的中心可能是某个字符也可能是某两个字符的间隙，因为字符串的字符数可能是奇数也可能是偶数。
字符数为奇数时，中心就是某个字符，此时left和right指针的起始位置都是这个中心字符。
字符数为偶数时，中心是两个字符的间隙，但我们不可能取间隙，所以left指向左边的字符，right指向右边的字符。
假设原字符串遍历到了i位置，如果以i为中心往外扩展比较检查连续回文子串最长是多少，假设计算回文子串的方法为getMax()，
getMax()要传递原字符串，left指针起始位置，right指针起始位置，结合中心的两种情况，需要调两次getMax方法计算。
例如：
int len1 = getMax(str, i, i); // 这是字符数为奇数时的情形，left和right的起始位置都是同一个中心字符
int len2 = getMax(str, i, i + 1); // 这是字符数为偶数时的情形，left指向中心左边这个，right指向右边这个字符
然后取其中最大的。
i+1如果越界了，getMax的越界判断会起作用了，

那么getMax中具体如何处理？
其实就是当str.charAt(left) == str.charAt(right)且left和right不越界时，就继续往两边找下一个字符比较，不同就结束。
例如：
public int getMax(String str, int left, int right) {
    while (left >= 0 && right <= str.length() - 1 && str.charAt(left) == str.charAt(right)) {
        // 两个对称位置的字符相同，就继续往两边探索
        left--; // 左指针往左移一位
        right--; // 右指针往右移一位
    }
    // 到这里说明已经碰到两字符不相同的情况了，此时left和right位于不相同的两个字符上
    // 那么回文子串的就大长度，要减去这两个不同字符所占的2个长度
    return right - left + 1 - 2;
}