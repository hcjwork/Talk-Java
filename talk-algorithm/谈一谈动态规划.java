时间是2025年6月1日，这一篇我想谈一谈怎么系统性地学习动态规划。<br>
首先先分析下关于动态规划我应该要掌握哪些方面：<br>
1、什么是动态规划<br>
2、动态规划是解决什么问题的<br>
3、一个问题出现了什么信息，可以考虑使用动态规划<br>
4、动态规划的通用步骤或流程是什么<br>
5、我如何熟练地考虑和应用动态规划的关键环节<br>
6、动态规划的经典问题<br>
7、对应一个新的问题能快速定位到使用动态规划并熟练解决<br>
8、对于一般性动态规划的空间压缩优化<br>
——————————————————————————————————————————————————————————————————————————————<br>
什么是动态规划？<br>

一个问题出现了什么信息，可以考虑使用动态规划？<br>
求最值。比如最大价值、最大满意度、最少重量等。

动态规划的要素有哪些？<br>
1、有几个维度的属性需要考虑，是否能缩减到两个维度，是否能缩减到一个维度。<br>
2、两个维度和一个维度的表格怎么设计和计算。<br>
3、如果最终确定为两个维度，假设纵向为i、横向为j，dp[i][j]怎么求。
如果最终确定为一个维度，假设为横向为j，dp[j]怎么求。<br>
4、选择i和不选i时，j能支撑选择和无法支撑选择时，会是什么样的组合情况。<br>

动态规划的通用步骤？<br>
1、确定属性维度。尽可能压缩为两个维度。<br>
2、维度绑定属性设计（以二维属性为例）。<br>
横向j，一般绑定已知的最值属性。如问题中要求在最值M下通过选择物品或方案达到另一个最值V。
这个M对应的属性就作为横向j的维度属性，例如背包的最大容量、可供使用的最大预算等。
j的取值范围为0~M，注意要包括0和M。

纵向i，一般绑定可选属性。如问题中要求在最值M下通过选择物品或方案达到另一个最值V。
这个物品或方案就作为纵向i的维度属性，例如可选物品、可选工具等。
假设可选物品总数为N，i的取值范围为0~N，注意要包括0和N。
3、二维属性数组创建。
第一维（后面的[]）对应横向j，最值为M，第一维数组长度设置为M+1。因为从0到M，可以最少分出M+1种情形。(不管M给的示例值是多少，分成M+1份就OK了)
第二维（前面的[]）对应纵向i，最值为N，第二维数组长度设置为N+1。因为从0到N，可以最少分出N+1种情形。
例如：int[][] dp = new int[N+1][M+1];
4、二维属性数组遍历和赋值。
假设使用i遍历纵向，使用j遍历横向，二维数组的元素即可表示为dp[i][j]。
遍历过程的dp[i][j]的赋值即可抽象为三种情形：0可用、j条件下无法支撑i、j条件下可以支撑i。
1）i为0或j为0
i为0表示有0个物品（或其他）可选，可达到的最值V是0。
j为0表示有0个容量（或其他）可用，可达到的最值V是0。

伪代码：
if (i == 0 || j == 0) {
    dp[i][j] = 0;
    continue;
}

2）容量j无法支撑选择物品i
假设物品i所占容量为W[i]，如果j < W[i]，那想选也选不了，只能不选物品i。
那么最值V = 前一个物品在容量为j的条件的能达到的最值V'。

伪代码：
if (j < W[i]) {
    dp[i][j] = dp[i-1][j];
}

3）容量j可以支撑选择物品i
假设物品i所占容量为W[i]，如果j >= W[i]，那就可以选也可以不选。
不选就跟选不了一样，dp[i][j] = dp[i-1][j]。
选的话就要看是否有多种方案，因为有时候不是单个的物品i，可能是主件、附件有关联的。

例如：物品里包含主件和附件两大类，一个附件属于某一个主件，一个主件至多可有两个附件。但附件不能单独选择。
这时就需要考虑容量j所能支撑选择物品i的多种方案：
① 当前是附件，不能单独选择，直接跳过。
② 选主件+0个附件。
③ 选主件+附件1
④ 选主件+附件2
⑤ 选主件+附件1+附件2
除了直接跳过的，其他的情形，每一种都要分开计算下，然后取所有情形中的最值V。
而有具体选择物品时，最值V = 已选物品的各自的最值V' + 在容量j去除已选物品所占容量j'的条件下上一个物品能达到的最值V。
如：最值V = V' + V'' + dp[i-1][j-j'-j'']; 

伪代码：（注意不能用else if或else，要让每种情况都跑一遍）
// 不选
int max = dp[i-1][j];
if (附件) {
    continue;
}
if (选主件+0个附件) {
    max = Math.max(max, 选"主件+0个附件"时的最值V);
}
if (选主件+附件1) {
    max = Math.max(max, 选"选主件+附件1"时的最值V);
}
if (选主件+附件2) {
    max = Math.max(max, 选"选主件+附件2"时的最值V);
}
if (选主件+附件1+附件2) {
    max = Math.max(max, 选"选主件+附件1+附件2"时的最值V);
}
// 最后设值
dp[i][j] = max;

5、空间压缩优化。
如果是二维属性数组，可以优化为只用横向j的一维数组。假设这个一维数组定义为：int[] dp = new int[j]。
因为在常规做法中dp[i][j]的计算依赖可以抽象为两个方向，一是dp[i-1][j]，一是dp[i-1][j-j']。
可以发现从横向来看，只依赖了上一行，所以只需要维护i-1行的一维数组dp[j]即可。
也没有纵向i需要遍历了，但是横向j需要从右往左逆序遍历，因为我们在横向上计算需要依赖于j左侧的数据。
因此要逆序遍历，防止覆盖掉还没来得及使用的左侧数据。

无论是选择物品还是不选择，还是有多种选择，常规做法的dp[i][j]求值可以抽象为：
dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-j'] + V');
如果压缩空间，则可以抽象为：
dp[j] = Math.max(dp[j], dp[j-j'] + V');

伪代码：
int[] dp = new int[M+1];
for (int i = 0; j < N; j++) {
    // 逆序遍历。且只看能支撑物品i的情形
    for (int j = M; j >= j'; j--) {
        dp[j] = Math.max(dp[j], dp[j-j'] + V');
    }
}

for (int i = 0; j < N; j++) {
    // 逆序遍历。且只看能支撑物品i的情形
    for (int j = M; j >= 0; j--) {
        // 初始化
        // 能支撑选、不能支撑选
        if (j < j') {
            //
        } else {
            //
        }
    }
}
