应用程序要想在计算机正常运行，硬件资源是必需的，比如CPU资源、内存资源、磁盘资源等。
磁盘资源可有可无，但CPU和内存则必不可少，因为程序指令的执行只能由CPU完成，线程的生命周期、数据交互等则都需要内存空间支撑。

一个程序正常运行所需的内存称为运行内存或运行时内存，Java程序要正常运行自然也不少了内存的支撑，而Java程序的编译、解析、执行等
核心操作以及与操作系统交互的操作都是由Java虚拟机（Java Virtual Machine，JVM）来完成，因此Java官方对于每个大版本
都发布了相应的Java虚拟机规范以提供指导和约束。

可以说一个由Java语言编写的程序，其运行正依赖于具体的JVM来保证，而不同的JVM对JVM规范所提及的各种抽象的落地实现会有所差异，
常见的JVM有HotSpotVM、JBot等，其中使用最广泛的是HotSpotVM。

JVM运行时的内存称为JVM虚拟内存，所谓虚拟内存指的就是操作系统除了分配真实的物理内存外，还会结合部分磁盘空间来作为内存交换页。
因此虚拟内存是物理内存空间与其他存储空间的结合技术。

JVM运行时的内存区域为了方便管理被划分成了多个不同的区域，这些区域被称为JVM的运行时数据区（Runtime Data Area，RDA）。
JVM的运行时数据区具体分为程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区这5个大块。
虽然运行时数据区从逻辑上被分为了五大块，但实际上这五大块内存区域并非是完全独立隔离开的，假如一台机器的物理内存是5G，
不是说五大块每块分其中连续的1G内存区域，实际分配没有这么简单。

进程是资源分配的最小单位，线程是CPU调度的最小单位。
进程是指运行中的程序，运行中的Java程序也称为JVM进程。
线程是指线性化执行的程序，这里的程序是指的程序片段或控制流，并非是完整的程序，因此线程也被称为是轻量级的进程。
程序的方法是由线程来调用的，包括属性的访问，其实本质上也是方法调用，方法中的代码指令最终由CPU来解析执行，
现代CPU具体多核模型和超高效率，为了尽可能利用CPU的性能，操作系统通过时间周期控制和线程阻塞唤醒轮转，从逻辑上将CPU的执行
切分非常细密的时间片，CPU本身没有这种分法，只是来一个指令就执行一个指令，但操作系统会在内核中维护线程阻塞队列，
随机唤醒其中一个线程，运行状态中的线程单次持有固定时间的CPU执行权，拥有CPU执行权的线程将机器指令传递给CPU执行，
固定时间一到当前线程进入阻塞状态，操作系统再随机唤醒一个线程（有可能是刚才的线程再次获取到CPU执行权）。
因为这个机制，线程被认为是CPU调度的最小单位。

为什么要说这部分东西，因为对于JVM进程来说，实际的代码执行也是由一个个线程根据程序控制流按步完成的，因此JVM运行时数据区
就有了线程私有和线程共享的分别。在五大块区域中，程序计数器、Java虚拟机栈和本地方法栈是线程私有区域，Java堆和方法区是
线程共享区域。所谓的私有指的就是其中存储的数据在线程之间是隔离的，每个线程都有自己的一份独立隔离的这些内存区域。
所谓的共享值的就是其中存储的数据在线程之间不是隔离的，一个线程能操作到其它线程修改过的数据。
内存区域可以在线程间保持隔离私有，是通过CPU寄存器或CPU栈指针寄存器等硬件保障的。其实也是逻辑上的隔离，
并非是将内存从物理层面给切分隔离了。

这个线程私有明明是硬件层面的事情，那Java线程为什么也能享受这种效果呢？这是因为Java线程和OS线程是一对一的关系，
每当提供Java代码创建一个线程时，最终都会在OS中对应也创建一个线程。当OS线程切换时，会自动切换对应的寄存器和内存上下文。
从这个机制可以看出，当线程数量越大时，线程的上下文切换就会越频繁，因为CPU时间片的时间是固定的，线程多了，随机调度到
不同线程的概率自然也就增大了。因此线程并发数在一定程度上能提供程序的性能，但也并非是越多越好。

既然是私有区域的隔离性由硬件来保证，那么JVM就不用做过多工作了，不过会在启动时为每个线程预分配私有内存空间，
这个栈空间大小可以`-Xss`参数指定。但共享区域对于JVM来说是管理重点区域，尤其在并发场景，得通过同步机制（比如锁、CAS）
来保证并发访问的安全。例如为一个新创建的对象在Java堆中分配内存，就需要给Java堆内存区域上锁，否则就有可能让别的对象覆盖了
原本给当前对象所分配的空间。

程序计数器、Java虚拟机栈、本地方法栈的生命周期与线程绑定，线程终止时其相关的这部分内存空间会被回收。
Java堆和方法区因为是共享区域，所以生命周期是与JVM进程绑定，只有JVM终止时这部分内存空间才会被回收。

程序计数器存储的是下一条要执行的指令的行号。

Java虚拟机栈和本地方法栈则存储的是一个个栈帧（Stack Frame），只不过Java虚拟机栈是为普通方法服务的，而本地方法栈则是为
native方法服务的。
线程每调用一个方法就就会生成对应的栈帧存储到栈中，先调用的方法对应的栈帧存储在栈中的下面，后调用的方法对应的栈帧存储在栈中
的上面，每退出一个方法就会弹出对应的栈帧，对应的内存区域就会被回收。
栈帧存储有局部变量、操作数栈、方法返回地址、动态链接等信息。局部变量为非共享数据，只在方法中有效。
局部变量表中存储方法参数，对于非静态方法，还有个默认的this实例地址，this实例即当前类的实例。
操作数栈会存储计算的中间结果，方法返回地址则记录方法退出时要返回的原方法中的指令地址信息，动态链接则记录要调用的其他方法的
引用地址。

Java堆存储的是对象实例，包括数组实例，对象实例包含实例方法、实例属性等数据。在jdk1.8开始，还包含字符串常量池的存储。
方法区存储的类相关的数据，比如类结构、元数据、继承的父类、实现的接口、静态属性、静态方法、常量池等。

方法区存的是类的数据，但在JVM运行过程中，类的数据只会被加载和存储一次。而对于Java堆，如果对象不是单例模式的，其创建的对象
会在Java堆中独立存储多份，比如自定义对象Student，每次通过new关键字创建一个Student，哪怕每次对属性赋予同样的值，
都会独立分配一块内存空间进行存储，因此new关键字创建的对象的内存地址是不相同的。
而对于单例模式创建的对象，只会在第一次分配内存空间，后续都是指向同一个内存地址。像Java的枚举类型，在JVM层面时是有做
内存分配控制的，并且禁止反射和反序列化，因此天然具有单例效果，是非常好的一种单例模式实现。

在jdk1.7之前字符串常量池还放在方法区中存储，后来因为实际工程应用里字符串使用太过频繁，字符串常量池很快耗尽方法区的内存空间，
当方法区内存不够用时，JVM会发起FullGC，FullGC停顿时间较长。为了减少GC频次，让方法区在类的加载和存储上有更多的空间可用，
在jdk1.7开始将字符串常量移入了Java堆中存储。

在jdk1.8之前，方法区的落地实现被称为永久代（PermGen），使用的是虚拟内存，具体来说是Java堆的内存。
在jdk1.8开始，方法区的落地实现被替换为了元空间（Metaspace），使用直接内存也就是物理内存，
使用直接内存还能减少磁盘数据页的转换所带来的开销，其可用空间也不再受限于JVM虚拟内存，但受限于物理内存，所以也会存在OOM的可能。
尤其是在实际工程里，会通过`-XX:MaxMetaspaceSize`给元空间设置一个上限，所需内存超过这个上限是就会触发FullGC。
FullGC会卸载不再使用的类加载器及其关联的类元数据（Klass），若元空间无法释放足够内存，则抛出`OutOfMemoryError: Metaspace`。
应用动态加载大量类（如Spring AOP、反射生成类），也可能会触发元空间的OOM。

根据JVM规范所言，广义上的堆涵盖了所有共享区域，方法区也是共享区域，本身在逻辑上是属于Java堆的一部分，而且规范中并没有
强制要求方法区必须实现，只是在概念提出有这么个共享区域称为方法区。
所以在jdk1.8之前的方法区落地实现永久代，其内存空间是Java堆中从逻辑上分出来的，其内存受限于Java堆的大小，
比如通过`-Xmx`指定的最大堆内存大小，而通过`-XX:MaxPermSize`指定的内存大小实际最多只能到达`-Xmx`的大小。
而jdk1.8开始的元空间，基于物理层面从Java堆中独立了出来，直接使用物理内存，其理论上限只取决于具体的物理内存大小，而与
Java堆最大大小无关。也不需要关注内存的碎片问题，直接由OS管理。另外在GC上，元空间的类卸载基于类加载器存活判定，
而非永久代的全局扫描，FullGC压力更小。










