一个Java对象是根据Java类的构造方法创建的，但对于抽象类和接口，即便是由构造方法无法直接用作本身对象的构造依据，
像抽象类的构造方法是给子类实例化用的，并不是给抽象类本身实例化用的，抽象类本身无法实例化。
而一个可以实例化的类，其包含的字段、方法、代码块都有静态和非静态之分，对于静态字段、静态方法、静态代码块是隶属于类本身的，
与类的元数据信息一同存储在方法区中，而对于非静态字段、非静态方法、非静态代码块是隶属于类实例的，与实例对象一同存储在Java堆中。
所以一个Java对象的大小计算是只关注非静态相关的定义的。

一个Java对象由对象头（Objet Header）、实例数据（Instance Data）、对齐填充（Padding）三部分组成，这三部分共同决定了
一个Java对象究竟需要多少内存才能存下。
在64位的JVM中，为了提高CPU读取内存的效率、避免缓存行的伪共享问题，要求一个Java对象的总大小为8字节的倍数，
如果对象头和实例数据两部分的大小总和不是8的倍数，则对该对象进行内存对齐填充，使总大小刚好为8字节的倍数。
比如一个没有任何字段的类实例对象，对象头占12字节，实例数据占0字节，对象头+实例数据占12字节，不是8字节的倍数，因此要填充
4字节，总大小为16字节刚好为8字节的倍数。

对齐填充部分要填充多少内存，由对象头和实例数据两部分的大小总和确定。

实例数据部分的大小则取决于该对象的所有非静态字段，对应的变量是什么类型。如果是引用类型的字段每个都占8字节，如果是基本类型的
则根据具体8大基本数据类型确定，boolean、byte占1字节，short、char占2字节，int、float占4字节，long、double占8字节。
如果JVM开启了指针压缩（可通过`+XX:+UseCompressedOops`参数开启，默认开启），引用类型的字段所占内存空间压缩为4字节。
基本类型的字段所占内存不受指针压缩影响。指针压缩仅优化对象引用，基本类型字段大小由JVM规范固定。
引用类型字段的值其实是对应实例的内存地址，是Java堆中存储该对象的内存的起始指针，用于唯一标识该对象在内存中的位置。
Java中的所谓内存地址并非是物理内存地址，而是由JVM管理的虚拟内存地址。
所以结合JVM的位数（是64位还是32位）、是否开启指针压缩（开启时引用占4字节，不开启占8字节）、字段数据类型，便可以计算出
一个Java对象的实例数据部分究竟占多少空间。

对象头由标记字段（Mark Word）、类型指针（KClass Pointer）、数组长度（Array Length）三部分组成。
其中数组长度只有数组对象中才有。
标记字段占8字节（即64位），类型指针占8字节，数组长度用int表示，占4字节。
类型指针是指向方法区中类元数据的指针，即对象所属类的类元数据的内存地址，在64位JVM中默认占8字节，开启指针压缩时占4字节。
标记字段则固定占8字节64位，不受指针压缩影响，包含对象的哈希码、GC分代年龄、锁状态、偏向模式等关键数据。
数组长度固定是4字节，不受指针压缩影响。

凡是基本类型的所占长度不受指针压缩影响，凡是实例引用的内存地址默认占8字节，被压缩后占4字节。因此一个Java对象的内存大小
计算要根据是否开启指针压缩和所用JVM位数来决定。

Object类是Java中的顶级父类，没有任何字段，因此一个Object类的实例对象（默认64位JVM和开启指针压缩），
对象头所占内存为`8字节+4字节=12字节`，实例数据占0字节，对齐填充占4字节，总共所需内存大小为16字节、


