OOM，Out Of Memory，内存溢出，指的是程序在执行时申请新的内存空间却没有足够的内存空间可用，
即程序正常运行所需的总内存超过了最大可用内存。此时JVM会抛出OutOfMemoryError。

其实对于Java程序而言，内存溢出在Java堆、方法区、栈都是可能出现的，因为理论上可用内存不管是虚拟内存还是直接内存，
都必然要受计算机的物理内存的限制。但程序开发者所讨论的OOM问题通常都是基于广义的Java堆而言，不涉及Java的栈。
所谓广义的堆，就是指的线程共享的区域。在JVM的内存区域中，有个运行时数据区（Runtime Data Area）的概念，
是JVM得以正常运行的重要内存区域，包含有程序计数器、Java栈、本地方法栈、Java堆、方法区。
其中只有Java堆和方法区这块内存区域是线程共享的，也是垃圾回收的区域。

探讨OOM异常时通常只讨论JVM的共享内存区域，其中一个原因就是，JVM必然先试过GC处理了，才会出现OOM异常。
而对于Java栈或本地方法栈来说，虽然也有内存溢出的情形，但抛出的异常是StackOverFlow异常，即栈溢出异常。
且Java栈、本地方法栈的内存随着这方法的栈帧出栈而自动回收，不需要JVM特别进行垃圾回收管理，因此与OOM异常没什么关联。

JVM会根据具体的内存区域出现的内存溢出而在OutOfMemoryError的基础上打印区域或说明原因，比如：
Java堆出现内存溢出时JVM抛出异常的关键信息为“OutOfMemoryError: Heap”；
方法区（以jdk1.8起的元空间实现为例）出现内存溢出时JVM抛出异常的关键信息为“OutOfMemoryError: Metaspace”。

还有些场景可能是大数组对象分配空间不足、TLAB线程本地分配空间不足。

Java堆中存储的是对象实例和数组，数组是基础数据结构，数组对象由JVM底层直接创建。
字符串常量池在jdk1.7之前时存储在方法区中的，为了降低方法区的GC频率（FullGC），jdk1.7开始将字符串常量池移入堆中存储。
所以除了对象创建过多导致Java堆OOM外，字面量形式的字符串、String.intern()方法处理后的字符串，都会加入到字符串常量池，
也是导致Java堆OOM的原因之一。
当然不能因为对象创建和字符串会导致OOM就因噎废食而不使用了，不过可以尽量减少不要的创建，
比如在代码中维护字符串常量类，复用高频字符串。使用小对象代替大对象，以减少老年代GC频次，也能降低OOM风险。

方法区存储的是类的元数据信息，比如类结构、类名、方法名、接口名、方法链接等，也存储了一些其他类型的常量池。
Java程序类实例的创建是需要先将类信息加载到方法区中，然后做验证、解析、初始化等工作之后，JVM才能知道怎么依葫芦画瓢创建类的实例。
但一个类的信息只会被加载一次，因此如果Java程序中创建的实例的类型过多，还是有可能导致方法区内存不够用，
即便在jdk1.8开始由元空间代替永久代，元空间所用的直接内存同样受物理内存限制，所以也会出现OOM问题。
对于Java程序中类，可以分成两种，一种是Java自身提供的或成熟框架提供的类，一种是程序开发者所定义的类。
可以管控的通常是第二种即开发者所定义的类，定义的类数量不宜太多太冗余，类中的属性、方法也不应包含太多，
还有类中属性的嵌套、方法的嵌套，也同样是值得斟酌优化的方向。

内存溢出的本质是所需内存大小超过了可用内存大小，而程序的所需内存是由业务需求和实现方式决定，肯定也有优化的空间，
但不排除本身是可用内存配置过低，业务实现所需内存量大，此时就需要酌情增大可用内存。
随着业务量的增长，程序所需内存也越来越大，所以在程序初始投产时就要为可用内存设置一个经验值，一般会结合机器的物理内存来考虑，
还要考虑机器的内存资源是否要与其他程序共享，比如Java堆的最大大小可能会设置为2G，方法区的最大大小可能会设置为518M。
如果机器的内存资源独享且可用量较大，则可以考虑将可用内存设为更大值，但Java堆的最大大小一般不会超过物理内存的1/4，
这也是JVM默认的Java堆的最大大小。

如果不出现OOM问题，初始设置的可用内存是相对合理的。一旦出现OOM问题，就需要分析是在哪个类中发生的，是什么原因导致的，
是程序编写不合理，还是可用内存本身设置就过低。综合考虑，单个调整，每次只调整一个点，然后继续测验运行结果，如果再出现OOM问题，
则进一步调整测验。工程实践中可以从程序优化和可以内存调整两方面同时着手。

OOM问题本身的解决方案可能并不复杂，关键是需要留存好OOM日志，方便快速排查和定位OOM问题根源所在。
OOM日志文件的生成，OOM日志文件的分析，相应问题的解决方案设计，具体的调整措施和验证指标，包括OOM问题产生和回溯的总结归档，
是OOM问题解决的通用流程。

JDK自带的jmap程序可以导出Java堆的转储信息，但jmap命令在执行时会导致Java程序停顿，影响Java程序运行，
在生产环境中不建议使用，但可以在开发或测试环境中使用，可以直接通过`jmap -heap`命令生成堆转储文件。
如果是生产环境，则在Java应用启动时通过`-XX:+HeapDumpOnOutOfMemory`参数开启OOM自动堆转储功能，
通过`-XX:HeapDumpPath`参数指定堆转储文件存储路径。
也可以使用Arthas的heapdump命令导出堆转储文件，但Arthas会挤占机器资源，具体选择还是依实际需求而定。

OOM时的堆转储文件生成好之后，可以通过JDK自带的JVisualVM程序分析堆转储文件，也可以使用MAT(Eclipse Memory Analyzer)、
JProfile等工具进行分析。
如果程序的运行日志有及时流程，可以先从程序生成的应用日志、gc日志等入手。