内存泄漏（Memory Leak）和内存溢出（Out Of Memory，OOM）是有差别的两回事。
内存泄漏，指的是资源没有及时释放而导致其所占内存长时间无法回收，在逻辑上相当于这部分内存泄漏出去了。
内存溢出，指的是程序申请新的内存空间时发现已经没有足够可用的内存空间了，所需的总内存超过了可用内存，导致程序运行异常。

内存泄漏是一种逻辑或概念上的现象，程序不会抛出什么异常。
但是因为泄漏的是可用内存，所以内存泄漏是内存溢出的诱因之一。
内存泄漏也会加速内存溢出或提高内存溢出的风险。

内存泄漏的常见场景：
内存泄漏一般是因资源未释放导致的，例如：IO流未释放、Socket连接未关闭、资源池未关闭、SFTP连接未关闭等。
还有ThreadLocal中ThreadLocalMap的Entry键值对对value的强引用，
如果没有及时调ThreadLocal对象的remove方法，就很可能发生内存泄漏。
还有些资源被线程池中的线程所调用，其生命周期与线程保持一致，
而线程池中的工作线程又一般很少销毁，这些资源就会一直被线程强引用，导致对应的内存无法及时回收。

可用内存就那么多，这里占一点那里占一点，剩下的就越来越少了，内存溢出的风险也就越来越大。

内存溢出的场景：
Java程序所占的内存主要就是JVM中所划分的运行时数据区（Runtime Data Area），运行时数据区分为：
程序计数器、堆、Java方法栈、本地方法栈、方法区。
这五个部分中，程序计数器和方法栈是线程所私有的，每个线程都有一份，生命周期与线程相同。
堆和方法区是所有线程所共享的，生命周期与JVM相同。

程序计数器就是用来记录下一条要执行的指令的行号，所占空间很小且稳定，不会出现内存溢出的场景。

方法栈倒是有可能出现内存溢出，因为方法栈里存放的是一个个栈帧，线程每调用一个方法就压入一个栈帧，
栈帧里包含局部变量表、操作数栈、动态链接、方法返回地址等数据，而方法栈的可用内存小，默认只有1MB，
当要调新的方法时没有足够的空间压入方法栈中，程序会抛出StackOverFlow栈溢出异常。
栈溢出异常发生在方法递归调用或嵌套层次过深时。
栈内存溢出本质也是内存溢出的一种，平常讲内存溢出可能是狭义地指堆内存溢出。
当然方法栈有配置可以调整为让方法栈自动扩容，但无论如何也不可能设置和物理内存一样大，那样的话其他运行时数据区就没空间了。
而且方法栈所占内存空间越大，程序的并发量就越低，因为可以创建的线程少了。
所以实际工程中反而是尝试把方法栈的可用空间调小以增加程序的并发量，比如利用-Xss参数将方法栈的初始大小由1MB设置为256KB。

方法区所占的内存比方法栈要大，但还是堆的空间最大。因为堆中存储对象数据，方法区则主要存储类相关的元数据。
这两块区域就是Java垃圾回收的区域，其他的程序计数器和方法栈，线程没了就自动回收了（操作系统帮忙），也不需要关注。

方法区是JVM规范的叫法，实际上有具体的落地实现，在jdk1.8之前这落地实现称为永久代，jdk1.8开始称为元空间（Metaspace）了。
jdk的这部分变化是有原因的，之前永久代使用的也是虚拟内存，空间有限，而且一开始还存着字符串常量池，
字符串常量会随着程序的迭代开发而越积越多，这部分数据又是根集合对象，很难被垃圾回收器回收，
而永久代本身肩负着类信息的存储，类加载得越来越多，剩余空间被挤压，字符串常量池又挤压剩余空间，很快永久代就会发生内存溢出，抛出的异常为“OutOfMemoryError: PermGen space”。
为了解决这些问题，jdk1.7将字符串常量池从方法区的永久代移到了堆中，这样就降低了方法区的内存溢出风险。
但有些程序类非常多，永久代的空间也时常不够用，后面jdk1.8干脆把永久代改为元空间，使用直接内存也就是物理内存。// 改为元空间的另一个原因是当时Oracle要HotSpotJVM兼容JBot？
虽然元空间的大小不受JVM的限制，当加载过多的类到元空间中，同样会导致内存溢出，程序抛出的异常为“OutOfMemoryError: Metaspace”。

永久代和元空间的大小都有配置可以调的，
例如元空间，可以通过参数-XX:MetaspaceSize调整初始大小，可以通过参数--XX:MaxMetaspaceSize调整最大空间大小。
如果初始大小和最大大小配置不同，就表示允许JVM在程序运行时适当扩大方法区的内存大小，也就是允许动态调整。
但需要注意的是动态调整会影响程序的性能，尤其是变动频繁时。

堆是JVM运行时数据区中最大的一块，也是垃圾回收的主要区域。这块内存空间用来存储Java对象，包括数组对象、Class对象等。
成员字段属于对象，所以也一并存在堆中。
jdk1.8时，字符串常量池也移到了堆中存储。
当JVM想要为新对象分配内存空间而连续的可用内存不足时，会先触发垃圾回收，
先是年轻代回收看能否存下，存不下再对老年代回收，老年代也存不下就会抛出异常““OutOfMemoryError: Heap”。

内存溢出与GC的关联：
内存溢出不是突然溢出的，而是在经历了一次次的垃圾回收后依旧无足够空间可用时才溢出的。
决定GC耗时的两大因素是：垃圾对象的数量和垃圾对象的大小。
GC主要针对堆和方法区两个部分，方法区空间不够时会触发FullGC，堆空间不够会先触发MinorGC，还不够会触发MajorGC。

内存泄漏和内存溢出对并发、性能和可用性的影响：
内存泄漏导致内存空间被挤占浪费，能够支撑的对象和类的存储量就会下降，所以导致程序并发量下降；
内存泄漏最终导致内存溢出，内存溢出时程序终止运行，程序的可用性大大降低；
内存泄漏挤压可用空间，会增加GC频次和耗时，程序的性能会下降。
内存溢出与内存泄漏类似，也会引起程序在并发、性能和可用性方面的能力下降。

