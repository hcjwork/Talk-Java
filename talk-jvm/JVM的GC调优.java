JVM在GC时暂停所有用户线程，避免在回收的过程中还不断产生新的垃圾对象或者原本是垃圾对象的又被引用了。
不同GC的停顿时间不同，越是范围大停顿时间越长，比如FullGC要回收整个Java堆和方法区，要停顿所有用户线程，
因此有STW（Stop The World，STW，停顿整个世界）的说法。

很明显，GC停顿时间越长对Java程序的影响就越大，GC的频次对Java程序性能影响也不小。
业务线程执行到一半突然来个GC停顿，每一小时就来三次GC，这必然导致程序的吞吐量下降、延迟增大、响应时间变长，
甚至还可能因为GC停顿让其他系统无法第一时间无法获取到预期时间内应该拿到的数据。

因此如果要对GC进行调优，就需要从GC停顿时间和GC频次两个方面入手。

一、影响GC频次的关键因素
1、对象的分配速率
对象的创建速率也代表着对象的分配速率。当对象创建过于频繁，就需要不断为新对象分配内存空间。单位时间内创建的对象越多，
Eden区被填满的速度越快，那么MinorGC就越频繁。
对应的优化方法就是，减少对象的创建，尽可能复用对象，比如使用常量、单例、对象池等。

2、堆内存的大小
可以用于对象内存分配的空间，也决定了GC的频次，尤其是新生代的大小。如果初始值就较低，那么JVM为了给新对象腾出可用空间，
就要频繁GC进行内存回收。如果堆的最大大小和初始大小不同，那么JVM在GC后发现内存不够用就会自动扩容，这扩容的过程也是会产生
线程停顿的。
因此最好是将堆的初始大小和最大大小设置为相同的值，以避免扩容所带来的停顿耗时。
当然这个值也要尽量设置大些，通常设置为2G左右比较合理，如果内存资源充足还可以酌情提高。

3、方法区的大小
以元空间为例，当类加载过多时会导致元空间不足，尤其是显示设置了最大大小时，会触发FullGC。
虽然没有存储对象实例，但类元数据和一些静态字段数据，还有一些常量池，都是需要占空间的。
而方法区的大小通常会设置得远小于堆，因此如果要加载的类比较多或是静态字段定义得比较多，要适当增大方法区的大小。
与堆一样，将方法区的初始大小和最大大小设置为相同的值，可避免自动扩容所产生的停顿耗时。
这个值一般设置为512M左右，如果内存资源充足可以酌情提高到1G。

虽然元空间是使用的直接内存，但工程实践一般都会设置一个最大大小，以避免挤占堆可用内存或是其他应用所需内存。

4、Survivor区的内存利用率
Survivor区是两个大小相同的区域组成的，称为S0和S1。Survivor区是新生代中的一部分，Eden区与S0和S1的比例可以通过
`-XX:SurvivorRatio`参数指定，此参数默认为8，即表示Eden:S0:S1=8:1:1。
当Survivor区空间不足时，新对象或是从Eden区GC中存活下来的对象，会直接晋升老年代，导致老年代很快填满，从而触发MajorGC。
如果MajorGC后无法存储晋升的对象，则触发FullGC，此时将产生STW停顿。
因此Survivor区的大小也决定着GC的频次，如果发现Eden区在一次GC后存活的对象较多（比如超过一半），就需要增大Survivor在
新生代区域的大小比例，或是直接增大堆内存。

5、老年代占有率
老年代空间不足，会加大FullGC的频次。因为老年代空间不足，会先进行MajorGC，即只针对老年的GC，
但如果MajorGC后老年代空间依然不足，会触发FullGC，将新生代和老年代再进行一次GC。
老年代的空间可以通过`-XX:NewRatio`参数进行调整，这个参数的含义是老年代与新生代大小比例，默认为2，
表示老年代和新生代比例默认为2:1，即老年代占堆的2/3。但我们可以看到老年代的空间一般会比新生代大，如果老年代的空间都不足了，
说明是堆空间不足，没有必要去增大`-XX:NewRatio`参数，那样会挤压新生代的空间，也会进一步增大GC的频次。
所以如果是新生代或老年代空间不足，直接调整堆的总大小就好了。

二、影响GC耗时的关键因素
1、对象的数量
毫无疑问，垃圾对象的标记与回收是GC耗时的最主要部分。
对象越多，要标记的数量就越多；存活下的对象的数量越多，要进行复制、整理等的开销就用越大。
所以要尽量减少对象的生命周期，降低对象在GC后的存活率，尽可能让对象只在Eden区中存在，避免复制到Survivor区或晋升到老年代。

2、堆内存的大小
理论上来说，堆内存越大，能存储的对象就越多，那么一次GC要扫描和整理的时间也就越长。
但其实本质还是在于对象创建的太多，堆内存大了也只能说是有更多空间分配给新对象了。

3、GC算法的选择
GC算法是采用串行、并行还是并发方式，这直接决定了GC的效率。GC效率高了其耗时自然也就降低了。
具体采用何种GC算法是由实际的垃圾回收器自行决定了，我们只需要关注不同的垃圾回收器就行了。
通常情况下，并行和并发要比串行效率高，但如果线程数过多可能因为频繁的上下文切换而GC效率平平。
所以应该选择并行或并发收集器，同时均衡并行或并发的线程数，最高上限要结合CPU核数来考量，不能设置过多。
比如通过`-XX:+UseParallelGC`参数指定使用并行收集器。

4、系统I/O性能
虚拟内存交换（Swap）或磁盘慢速时，GC停顿时间会延长。
禁用Swap，使用SSD（Solid State Disk，固定硬盘），可以提高系统I/O性能，减少GC耗时。

5、老年代内存碎片
老年代中要存储的是大对象或是多次GC后仍旧存活的对象，在MajorGC或FullGC之后，可用的空闲内存分散在不同的地方，不是连续的，
这就是内存碎片问题。为了给新对象腾出足够空间，保证有足够的连续空间分配给大对象，需要整理内存碎片，如果不整理，
可能会出现多次GC但回收效果依旧不理想的现象。所以内存压缩整理是必要的措施，程序启动时要开启压缩功能以整理内存碎片。


