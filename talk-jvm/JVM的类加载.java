一、类加载过程
Java是一种人类可读的高级语言，是面向对象编程，使用Java语言编写的代码文件被称为源文件，源文件以.java为后缀。
但高级语言无法直接被执行器解析执行，更不用说被CPU执行了，所以需要JVM编译器将.java源文件编译为.class字节码文件。
只要提供的字节码文件是合法的，在任何平台的Java虚拟机中都能够正常解析执行，所以Java具备有跨平台的特性。
预备要执行的字节码文件，会被JVM加载到方法区中，验证、准备、解析、初始化等流程顺利完成后，才能通过字节码文件来创建对象。
字节码文件其实就是编译的后类文件，这里的类是指用Java语言编写的所有源文件数据，包括普通类、抽象类、接口、枚举等。
因此字节码加载过程，就是类的加载过程，字节码和类是对同一事物的不同角度或阶段的描述。

既然是类的加载，那么肯定有个地方留存有类的信息，也就是字节码信息。需要从这些地方将字节码读取到方法区所属内存中，再基于内存
对字节码做后续处理。
字节码是需要持久化存储的，不然Java应用重新启动后字节码就被清除了，那肯定不行，因此通常是以磁盘文件做持久化存储，
即用.class文件存储。
字节码的根本来源肯定是某个文件。对于某个JVM来说，字节码的来源除了本机的文件外，也可能是其他机器的文件或者是网络传输中的数据流。
想要字节码文件被正常执行，就必须保证字节码文件是符合JVM规范的。

标准的字节码文件必须以魔数`0xCAFEBABE`开头，表示接下来的数据是字节码。
还要包含主次版本号，JVM会校验JDK/Java版本是否兼容。
另外字节码文件是源文件编译而成的，JVM加载字节码文件是为了对象创建。
对象创建时需要先将该对象所依赖的、所继承的、所实现的其他源文件的字节码文件先加载解析，
否则无法让创建出来的对象的属性、方法等特性达到预期。
所以除了字节码文件本身的规范外，字节码文件在类的节本结构、属性、方法等各方面也需要合乎规范，比如是否缺失、是否冗余等，
还包括其所引用或依赖的包名、类名、链接等，也要检验是否有效。

字节码文件的加载，其实就是从磁盘或网络中读取到JVM运行时数据区的方法区内存区域中，所以JVM每次重启都要重新加载一遍字节码文件。
但只要在JVM处于正常的运行状态中，字节码文件也就是类只用加载一次，校验通过的后续直接复用即可。
根据这个特性，我们可以将比较繁杂的或使用率高的或只需要加载一次的数据，放在JVM启动时一道加载了，
就可以减少JVM运行时非业务处理的性能挤占，即所谓的数据预加载。

字节码文件成功加载到JVM内存中，为了保障JVM的安全性，在使用前必须要先进行规范性检验，只有符合规范的才有往下操作的必要性。

一个字节码文件是由Java类（这里的类指的是广义上的类，而不是单指class关键字修饰的）编译而成，那么肯定要检验类本身的信息是否合法。
包名的全路径、引用的类的全路径、权限修饰符、关键字的使用、所继承的父类、所实现的接口、属性、方法、所依赖的属性、所调用的方法等，
检验是否缺失、是否有效。
类本身的各项信息要检验，但这之前先要检验字节码文件整体是否符合规范，比如有没有包含什么恶意代码或指令、是不是标准的字节码文件、
是不是可兼容的字节码指令。因为Java不同版本之间可能有较大差异，高版本中可能废弃了一些效率不高的代码、低版本无法兼容高版本的新特性。
JVM规范要求标准的字节码文件中要以魔数`0xCAFEBABE`开头，随后覆盖主次版本号，以供JVM检验是否可以兼容，避免使用时出现问题。
所以在加载过程完成之后，便是验证过程，主要就是检验字节码文件本身和类的元数据是否符合规范、是否有效。

一个类中的属性和方法有静态和非静态之分（即是否由static关键字修饰），静态属性和静态方法是属于类的，
而非静态属性和非静态方法是属于类的实例的。因此一个类的静态属性和静态方法相关元数据是和类的字节码文件一样存储在方法区中。
也就说静态属性和静态方法的生命周期适合类的字节码文件同频的，静态属性所需内存空间，需要在使用前给分配妥当。
所以在字节码文件验证无误后，如果类有静态属性，要计算好所需内存并在方法区进行分配。静态属性包含静态变量和静态常量。
如果是静态变量但没有显示赋值，JVM还需要给静态变量赋予初始值，比如0、null、false等。
如果是静态常量（用static final修饰的），也会在这个阶段直接赋值为代码中所指定的值。
静态属性如果是引用类型的，则给静态属性。
以上就是验证过程之后的准备过程，包含所需内存计算、静态属性赋值等工作。

验证没问题，准备工作也完成，接下来还有做一个工作就是进行符号和引用替换。
比如所依赖的其他类的实例对象、所依赖的方法、所继承的父类、所实现的接口等，需要将字面量替换为直接引用，
例如方法链接地址、实例对象内存地址。这部分是解析过程，即将符号和字面引用替换为直接引用。

解析工作完成后，需要将静态变量赋值为代码中所指定的值，如果是引用类型的，则将对应实例的内存地址赋值给当前变量。
然后执行静态代码块中的代码。这部分是初始化过程。

总结来说，类加载包括加载、验证、准备、解析、初始化这五个过程，每一步都是JVM保证类加载和使用安全与效率的重要步骤，
具体工作由JVM中的类加载器来完成。


二、类加载器
Java中的类加载器根据加载的字节码文件范围和职责有不同可以分为：
启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、
系统类加载器（System ClassLoader，也称为应用程序类加载器（Application ClassLoader））、

其中启动类加载器、扩展类加载器和应用程序类加载器是JDK（Java Developer Kit，Java开发工具包）自身提供的，
自定义类加载器则是程序开发者通过继承ClassLoader而自定义的类加载器。

启动类加载器负责加载JRE（Java Runtime Environment，Java运行时环境）下lib根目录中的字节码文件；
扩展类加载器负责加载JRE（Java Runtime Environment，Java运行时环境）下lib目录下ext子目录中的字节码文件；
应用程序类加载器则负责加载用户类路径（ClassPath等）下的字节码文件。

启动类加载器是扩展类加载器的父加载器，扩展类加载器是应用程序类加载器的父加载器。

三、双亲委派模型/机制
从抽象类ClassLoader中的两个核心方法loadClass和findClass可以知道，JVM准备加载一个类时，
会先检查当前类是否已经被加载过了，如果没有被加载过则提交给父加载器进行加载，如果也不属于父加载器所负责的范围，
则继续往上提交直到顶层的启动类加载器，如果都不能加载则往下回传，交由当前类对应的类加载器加载。

当一个类加载器接收到类加载请求时，如果该类没被加载过，会先委派给其父加载器，由父加载器尝试加载，如果所有的父加载器都无法加载，
则最终由其自身来加载。这就是Java类加载的双亲委派模型。

四、双亲委派模型的作用
双亲委派模型可以保证一个类在JVM运行过程中只被加载一次，同时也能保证类加载的安全性，
避免一些与Java核心类同名的用户自定义类干扰到核心类库的加载，
另外不同的类加载器之间分工明确，能避免类加载器的任务量偏斜或混乱失序。

五、打破双亲委派模型
双亲委派的关键特性：1、每个类加载器只负责固定路径下的类的加载；2、子加载器可以将类加载请求传递给父加载器，但
反过来不行，也就是说类加载器请求只能向上委托，不能向下委托。

如何打破双亲委派？
1、破坏双亲委派特性。比如父加载器委托类加载请求给子加载器。
2、继承ClassLoader抽象类，重写loadClass和findClass方法。比如直接加载指定版本的类，不委托父加载器。

为什么要打破双亲委派？
1、解决基础框架（核心类库）无法调用用户代码的问题，
通过TCCL（Thread Context ClassLoader，线程上下文类加载器）绕过层级限制，实现父类调用子类加载的代码。
2、动态性需求，比如热部署、多版本隔离等，可以指定要加载的版本。
3、安全性和个性化需求。通过自定义类加载器逻辑，能实现更灵活的类加载策略。

打破双亲委派模型的典型实例：
1、JDBC的驱动加载
DriverManager是JDK的lib目录的rt.jar包下的核心类，用于管理数据库驱动，是由启动类加载器负责加载。
Driver也是rt.jar包下的，Driver是一个接口，定义了JDBC（Java Database Connectivity，Java数据库连接）的规范方法。
数据库厂商都需要实现这个Driver接口，比如MySQL的com.mysql.cj.jdbc.Driver。
但Java的双亲委派有几个特点：一，每个类加载器只负责固定路径下的类的加载；二，子加载器可以将类加载请求传递给父加载器，但
反过来不行，父加载器无法加载子加载器所负责的路径下的类。
而Java提供的是Driver接口，因此如果要获取具体实现，就必须要加载实现了Driver接口的子类，
但Driver接口的实现类是用户路径下的，启动类加载器加载不了，因此就需要想办法获取到应用程序类加载器，
具体做法是通过ServiceLoader或直接调用Thread.currentThread().getContextClassLoader()，
反向获取应用程序类加载器来加载Driver接口的实现类。
在这个过程，父加载器将类加载请求下传给了子加载器，打破了原始的双亲委派特性。
DriverManager是启动类加载器加载的，但通过上下文类加载器间接加载了应用类加载器所负责的Driver实现类。

2、模块热部署

3、多版本兼容

4、安全性隔离

