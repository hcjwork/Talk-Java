S0区也称为From区，S1区也称为To区，JVM永远让只让其中一个区存储对象。每次GC时，将S0区中的非垃圾对象复制到S1区，
然后清理掉S0中的所有对象。

一个新对象被创建时，会现在Eden区中尝试分配，如果Eden区没有足够空间则进行一次MinorGC，
MinorGC之后仍没有足够空间存下新对象，则尝试在老年代为新对象分配内存空间，
老年代如没有足够进件则进行一次MajorGC，MajorGC后如果仍然没有足够空间，则进行一次FullGC，
FullGC后如果无法存下新对象，则抛出OutOfMemoryError异常，JVM进程终止。
FullGC是对新生代、老年代和方法区都进行回收，FullGC会先执行MinorGC和MajorGC。

对于较小的对象，可以在Eden区中存得下，在经历过MinorGC或FullGC后如果还能存活，存活对象被拷贝到Survivor区
的S0区，存活对象的GC年龄加1。

MinorGC或FullGC时，Survivor区的S0中的对象也要经历一轮标记回收过程，非垃圾对象拷贝到S1中，这部分的对象的GC年龄加1，
S0区域的对象全部清除，S1当作新的S0，原S0当作新的S1。
当存活对象的GC年龄达到阈值（默认为15，可以通过`-XX:MaxTenuringThreshold`参数修改）时，晋升到老年代存储。（晋升老年代条件1）
如果在一次GC后Survivor区中某一年龄的存活对象数超过了Survivor区中存活数的一半，所有大于这一年龄的对象都直接晋升老年代。（晋升老年代条件2）
在MinorGC或FullGC后，Eden区存活的对象如果不能在Survivor区中存下，则直接晋升到老年代。（晋升老年代条件3）
还有种情况JVM的`-XX:PretenureSizeThreshold`参数被设置了固定值（默认为0表示不启用）时，新对象的大小超过此阈值，
其内存空间则直接在老年代中分配。（晋升老年代条件4）

FullGC会先执行MinorGC（清理新生代），再清理老年代和元空间。元空间如果触发垃圾回收就是FullGC。
FullGC是对JVM的两大共享区域都做垃圾回收处理，因此停顿时间长，可能达到秒级。
如果FullGC频繁先排查时Java堆的引起的还是方法区引起的。
如果是Java堆的引起,可以通过增大`-Xmx`来增大老年代空间，以减少FullGC频次；
如果是方法区引起的，可以通过增大`-XX:MaxMetaspaceSize`来增大元空间，以减少FullGC频次。

GC频次跟内存大小有关，也跟对象创建频率有关。触发的GC类型则是与对象的大小和对象的引用范围有关。
尽量减少大对象的创建或是适当增大Eden区的空间，可以减少MajorGC和FullGC的次数。
至于GC的耗时是与对象的数量和对象的引用范围有关，所以减少对象创建和减少对象引用深度可以降低GC耗时。
当然GC算法和垃圾回收器的选择也影响着GC的耗时。
