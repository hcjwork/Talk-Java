程序计数器存储的就是指令行号，所占空间极小且每时每刻都要用，不能也无需回收。
Java虚拟机栈、本地方法栈存储的是方法的栈帧，方法退出时弹出对应的栈帧，其内存会自动回收。
因此垃圾回收需要关注的区域就是Java堆和方法区，这两块也是JVM运行时数据区中空间最大的两块内存区域。

JVM的垃圾回收根据影响范围可以分为MinorGC、MajorGC、FullGC三种，其中MinorGC又称为YoungGC，MajorGC又成为OldGC。
MinorGC是指的Java堆中新生代的垃圾回收，MajorGC是指的Java堆中老年代的垃圾回收，FullGC指的是Java堆整个区域或方法区的垃圾回收。
如果是Java堆，在发起FullGC前一定先经历过了MinorGC或MajorGC，MinorGC或MajorGC后空间仍不够才会触发FullGC，
FullGC后空间还不够就会抛出OutOfMemoryError。根据Java堆和方法区的不同又在抛出时有所差异，Java堆OOM时抛出
`OutOfMemoryError: Heap`，方法区OOM时抛出`OutOfMemoryError: Metaspace`（元空间的，永久代为PermGen）。

为什么JVM要把Java堆分成新生代和老年代？
在Java堆中存储的对象大小可能差别较大，各自的生命周期长短也有差异。
对于大的对象，需要更多的连续空间来存储。
对于被引用频繁或引用范围广的对象，生命周期更长。
但从工程实践来看，大对象和大范围引用对象的占比是很少的，大多数还是小对象和小范围引用对象。如果不分代，大小对象混合管理，
在多次次GC后，大对象和引用范围广的对象依旧存活，内存空间回收起来复杂，垃圾回收耗时也更长，因为要扫描更多的引用链路。
不同的垃圾回收算法也不同的用法，但一般都不适用于混合场景。为了提高垃圾回收效率、JVM采用分代和分区的方式，针对性应用
具体的垃圾回收算法。

整个Java堆分为新生代（Young Generation）和老年代（Old Generation），新生代也称为年轻代。
新生代与老年代的大小比例默认为1:2，即老年代的空间是新生代的两倍。
新生代又分为伊甸园区（Eden区）和存活区（Survivor区），存活区包含两个大小相等的区域Survivor0和Survivor1，简称S0和S1。
Eden区、S0、S1的大小比例默认为8:1:1，即Eden区占新生代的8/10，两个大小相等的S区分别占新生代的1/10。
对于Eden区采用的垃圾回收算法是`标记-清除`算法，对于S区采用的垃圾回收算法是`标记-复制`算法，对于老年代和方法区采用的
垃圾回收算法是`标记-整理`算法。

垃圾标记：对Java对象进行可达性分析，如果沿着该对象的引用链路不能追溯到根集合，则认为该对象已经不可以达，能够标记为垃圾对象。
根集合：GC Roots对象集合，通常指的是生命周期与JVM进程一致的对象，比如静态变量、常量、应用程序上下文对象等。

在可达性分析之前，垃圾标记还有种引用计数法，记录对象被引用的次数，如果为0则标记为垃圾。但引用计数法不能解决循环引用问题，
比如对象A引用了对象B，对象B引用了对象C，对象C引用了对象A，对于ABC三个对象的被引用次数都是1，在引用计数法中被认为不是垃圾，
但其实这三个对象只是彼此相互依赖，并没有被其他对象引用，理论上应该全部标记为垃圾。
而可达性分析通过对引用链路的溯源，最终追溯到根对象的引用，便可以凭此判断对象是否能被标记为垃圾。

标记-清除：通过可达性分析将垃圾对象标记为可回收，JVM通过垃圾回收器回收垃圾对象所占的内存。
标记-复制：通过可达性分析将垃圾对象标记为可回收，然后将非垃圾对象复制到安全区域，最后通过垃圾回收器回收掉原内存区域。
标记-整理：通过可达性分析将垃圾对象标记为可回收，然后通过垃圾回收器回收垃圾对象所占的内存，最后将存活的对象压缩存储
到最前面的区域，剩下的区域全部清理以形成可用的连续区域。

内存回收，并不是真正清除掉已写的数据，而是通过多次覆写来进行来掩盖原数据。内存页在逻辑上被操作系统认为是无数据的，并非真的没有数据。

内存碎片化问题：内存碎片有外部碎片和内部碎片，外部碎片就是指的空闲内存由于分散在不连续的区域导致无法分配给大对象，
内部碎片则是由于对象内存分配有个对齐填充的机制，这部分对齐填充的是没有被充分利用的。
但在JVM垃圾回收中，内存碎片一般指的是垃圾对象被清除后所空闲的非连续空间，

内存分配方法-指针碰撞与空闲列表
空闲列表：
维护一个链表，记录所有空闲内存块的地址和大小。为对象分配内存时，先计算好对象的所需内存，遍历链表找到足够大的空闲块。
可以灵活利用碎片内存，适用于内存存在碎片化的场景，如标记-清除算法后导致的内存碎片化场景。但分配速度慢，因为要遍历链表。
指针碰撞：
维护一个指针（free_ptr），始终指向连续空闲内存的起始地址。
为对象分配内存时，指针向高地址移动指定距离，这个距离根据对象大小确定。（Linux和Windows中内存页的大小通常为4KB）
适用于内存绝对规整即无碎片的场景，如标记-复制算法后的内存区域。但依赖内存的连续性，内存出现碎片化后无法使用。


