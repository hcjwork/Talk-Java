设计 RPC 框架的核心是解耦“调用”与“实现”，通过代理、网络通信和序列化技术，让远程调用变得透明，
并通过服务注册与发现、负载均衡和容错机制来保证其高可用和高性能。（简介）

既然是远程调用，肯定有调用方和被调用方，这个被调用方就是服务提供者，调用方就是服务消费者。
服务提供者怎么暴露自己所提供的服务，服务消费者怎么感知自己应该要具体调用哪个服务实例呢？
这就需要一个独立组件来进行协调，这个组件就是服务注册与发现中心，比如Zookeeper、Nacos、Eureka等。
这个服务注册中心维护服务提供者的服务和地址信息，服务提供者启动时向注册中心注册自己所提供的服务名称、ip、端口等信息，
服务消费者向注册中心订阅自己所需要的服务，注册中心推送服务提供者地址列表给服务消费者，
服务消费者获取到服务提供者的地址列表后缓存到本地。注册中心感知到服务提供者的地址列表变化，
会重新推送最新数据给服务消费者，服务消费者接收新数据后更新本地地址列表。（服务注册与发现）

服务提供者在分布式系统中往往是多实例部署的，那么可用的服务地址就不止一个，服务消费者如何选择具体的服务地址进行连接和调用呢？
这就需要在服务消费者这一端实现对于服务提供者实例的负载均衡选择，常用的负载均衡策略有：
随机、轮询、最少连接数、固定ip哈希、一致性哈希等策略。
通常至少要实现轮询、固定ip哈希、一致性哈希三种最主流的策略。（负载均衡）

服务提供者通过负载均衡策略选定了服务提供者的其中一个实例，那么如何进行网络连接呢？如何进行服务调用呢？
RPC框架的网络连接通常会选择TCP协议。那么就可以使用基于NIO的IO多路复用模型的高性能的Netty框架来进行网络通信。
服务提供者启动时开启Netty服务器，监听来自服务消费者的调用请求；
服务消费者通过Netty客户端与服务提供者的Netty服务端建立连接，并进行服务调用与结果响应。（网络通信和IO模型）

网络连接建立后，要进行数据传输，那么数据结构的定义和序列化反序列化方式的选择就非常关键，应该选择高性能和小体积的序列化协议，
比如将Java对象基于二进制字节流进行转换，支持多种协议比如Hession、Protobuf、JSON等。（序列化和反序列化）

服务消费者和服务提供者基于Netty建立连接后进行服务调用时可能会失败，因此需要提供一种容错机制，
在调用失败时采取不同的应对策略，比如 Failover（重试其他节点）、Failfast（快速失败）、Failsafe（忽略异常）。（容错机制）

实现了服务注册与发现、服务调用负载均衡、网络通信、序列化和反序列协议、服务调用容错机制后，还剩下两个要点需要考虑：
服务消费者具体要怎么调用接口呢？服务提供者怎么知道要执行哪个接口的处理呢？
对于服务消费者，我们要让消费者像调用本地接口一样调用远程服务。
其实现方法就是：在服务消费者这一侧引入目标服务接口的定义，为目标服务接口生成代理对象。
调用代理方法时，代理将方法名、参数等信息封装成请求数据，通过Netty客户端发送给服务提供者。
服务提供者侧的 Netty 服务器收到请求，反序列化请求数据后，通过反射和代理调用本地实现，
请求处理结束后将执行结果序列化后发送给服务消费者。服务消费者收到响应，在反序列化结果进行解析处理，
这样就顺利完成了一次调用。（代理和调用）

以上就是设计一个RPC框架时应该要考虑的点。